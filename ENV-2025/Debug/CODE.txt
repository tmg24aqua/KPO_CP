Файлы проекта ENV-2025:
file ENV-2025.cpp:
//  : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include "pch.h"

int _tmain(int argc, _TCHAR ** argv)
{
	char LEXERROR[] = "Лексический анализ завершен с ошибками\n";
	char SYNTERROR[] = "Синтаксический анализ завершен с ошибками\n";
	char SEMERROR[] = "Обнаружены семантические ошибки\n";
	char POLISHERROR[] = "Ошибка при попытке преобразования выражения\n";
	char LEXGOOD[] = "Лексический анализ завершен без ошибок\n";
	char SYNTGOOD[] = "Синтаксический анализ завершен без ошибок\n";
	char SEMGOOD[] = "Семантический анализ завершен без ошибок\n";
	char POLISHGOOD[] = "\nПреобразование выражений завершено без ошибок\n";
	char MESSAGE[] = "--------------------КОНЕЧНЫЕ ТАБЛИЦЫ ЛЕКСЕМ И ИДЕНТИФИКАТОРОВ-------------------\n";
	char STOP[] = "Выполнение программы остановлено\n";
	char ALLGOOD[] = "Программа успешно завершена!\n";
	setlocale(LC_ALL, "rus");
	Log::LOG log = Log::INITLOG;
	In::IN in = {};
	in.text = nullptr;
	in.words = nullptr;
	try
	{
		Parm::PARM parm = Parm::getparm(argc, argv);
		log = Log::getlog(parm.log);
		Log::WriteLog(log);												
		Log::WriteParm(log, parm);										
		in = In::getin(parm.in,log.stream);
		Log::WriteIn(log, in);
		in.words = In::getWordsTable(log.stream, in.text, in.code, in.size);	
		In::printTable(in.words);
		Lex::LEX tables;
		bool lex_ok = Lex::analyze(tables, in, log, parm);
		// Проверяем, были ли ошибки ввода (недопустимые символы)
		if (in.ignor > 0)
			lex_ok = false;
		
		if (!lex_ok)
		{
			Log::WriteLine(log, LEXERROR, "");
			Log::WriteLineConsole(LEXERROR, STOP, "");
			// Освобождаем память перед выходом
			if (in.text != nullptr)
				delete[] in.text;
			if (in.words != nullptr)
				delete[] in.words;
			Log::Close(log);
			return 0;
		}
		else
		{
			Log::WriteLineConsole(LEXGOOD, "");
		}
		
		LT::writeLexTable(log.stream, tables.lextable);							
		IT::writeIdTable(log.stream, tables.idtable);							
		LT::writeLexemsOnLines(log.stream, tables.lextable);

		MFST_TRACE_START(log.stream);
		MFST::Mfst mfst(tables, GRB::getGreibach());							
		bool synt_ok = mfst.start(log);
		mfst.savededucation();
		mfst.printrules(log);													
		if (!synt_ok)
		{
			Log::WriteLine(log, SYNTERROR, "");
			Log::WriteLineConsole(SYNTERROR, STOP, "");
			// Освобождаем память перед выходом
			if (in.text != nullptr)
				delete[] in.text;
			if (in.words != nullptr)
				delete[] in.words;
			Log::Close(log);
			return 0;
		}
		else Log::WriteLineConsole(SYNTGOOD, "");

		bool sem_ok = Semantic::semanticsCheck(tables, log);					
		if (!sem_ok)
		{
			Log::WriteLine(log, SEMERROR, "");
			Log::WriteLineConsole(SEMERROR, STOP, "");
			// Освобождаем память перед выходом
			if (in.text != nullptr)
				delete[] in.text;
			if (in.words != nullptr)
				delete[] in.words;
			Log::Close(log);
			return 0;
		}

		tables.lextable.size = Polish::searchExpression(tables);		
		if (tables.lextable.size == 0)
		{
			Log::WriteLine(log, POLISHERROR, "");
			Log::WriteLineConsole(POLISHERROR, STOP, "");
			// Освобождаем память перед выходом
			if (in.text != nullptr)
				delete[] in.text;
			if (in.words != nullptr)
				delete[] in.words;
			Log::Close(log);
			return 0;
		}
		else Log::WriteLineConsole(POLISHGOOD,""); 

		Log::WriteLine(log, MESSAGE, "");
		LT::writeLexTable(log.stream, tables.lextable);							
		IT::writeIdTable(log.stream, tables.idtable);
		LT::writeLexemsOnLines(log.stream, tables.lextable);					
		Log::WriteLineConsole(MESSAGE, "");
		IT::writeIdTable(&std::cout, tables.idtable);							
		LT::writeLexTable(&std::cout, tables.lextable);							
		LT::writeLexemsOnLines(&std::cout, tables.lextable);

		bool gen_ok = Gener::CodeGeneration(tables, parm, log);							
		if (!gen_ok)
		{
			Log::WriteLine(log, SEMERROR, "");
			Log::WriteLineConsole(SEMERROR, STOP, "");
			// Освобождаем память перед выходом
			if (in.text != nullptr)
				delete[] in.text;
			if (in.words != nullptr)
				delete[] in.words;
			Log::Close(log);
			return 0;
		}
		else Log::WriteLineConsole(SEMGOOD, "");
		Log::WriteLine(log, ALLGOOD, "");								
		Log::WriteLineConsole(ALLGOOD, "");
		// Освобождаем выделенную память
		if (in.text != nullptr)
			delete[] in.text;
		if (in.words != nullptr)
			delete[] in.words;
		Log::Close(log);
		system("pause");
	}
	catch (Error::ERROR e)
	{
		Log::WriteError(log.stream, e);
		// Освобождаем память в случае исключения
		if (in.text != nullptr)
			delete[] in.text;
		if (in.words != nullptr)
			delete[] in.words;
		if (log.stream != nullptr)
			Log::Close(log);
	}
	catch (...)
	{
		std::cout << "Ошибка: Системный сбой" << std::endl;
		// Освобождаем память в случае исключения
		if (in.text != nullptr)
			delete[] in.text;
		if (in.words != nullptr)
			delete[] in.words;
		if (log.stream != nullptr)
			Log::Close(log);
	}
	return 0;
}

file Error.cpp:
#include "pch.h"
namespace Error
{
	ERROR errors[ERROR_MAX_ENTRY] =
	{
		ERROR_ENTRY(0, "Системная ошибка: Недопустимый код ошибки"),
		ERROR_ENTRY(1, "Системная ошибка: Системный сбой"),
		#pragma region A
		ERROR_ENTRY_NODEF(2), ERROR_ENTRY_NODEF(3), ERROR_ENTRY_NODEF(4), ERROR_ENTRY_NODEF(5),
		ERROR_ENTRY_NODEF(6), ERROR_ENTRY_NODEF(7), ERROR_ENTRY_NODEF(8), ERROR_ENTRY_NODEF(9),
		ERROR_ENTRY_NODEF10(10), ERROR_ENTRY_NODEF10(20), ERROR_ENTRY_NODEF10(30), ERROR_ENTRY_NODEF10(40),
		ERROR_ENTRY_NODEF10(50), ERROR_ENTRY_NODEF10(60), ERROR_ENTRY_NODEF10(70), ERROR_ENTRY_NODEF10(80), ERROR_ENTRY_NODEF10(90),
		#pragma endregion A
		ERROR_ENTRY(100, "Системная ошибка: Параметр -in должен быть задан"),
		ERROR_ENTRY(101, "Системная ошибка: Превышена длина входного параметра"),
		ERROR_ENTRY(102, "Системная ошибка: Ошибка при открытии файла с исходным кодом(-in)"),
		ERROR_ENTRY(103, "Системная ошибка: Ошибка при создании файла протокола(-log)"),
		#pragma region B
		ERROR_ENTRY_NODEF(104), ERROR_ENTRY_NODEF(105), ERROR_ENTRY_NODEF(106), ERROR_ENTRY_NODEF(107), ERROR_ENTRY_NODEF(108), ERROR_ENTRY_NODEF(109),
		ERROR_ENTRY_NODEF10(110), ERROR_ENTRY_NODEF10(120), ERROR_ENTRY_NODEF10(130), ERROR_ENTRY_NODEF10(140),
		ERROR_ENTRY_NODEF10(150), ERROR_ENTRY_NODEF10(160), ERROR_ENTRY_NODEF10(170), ERROR_ENTRY_NODEF10(180), ERROR_ENTRY_NODEF10(190),
		#pragma endregion B
		ERROR_ENTRY(200, "Лексическая ошибка: Недопустимый символ в исходном файле(-in)"),
		ERROR_ENTRY(201, "Лексическая ошибка: Неизвестная последовательность символов (не распознана ни одним графом)"),
		ERROR_ENTRY(202, "Лексическая ошибка: Превышен размер таблицы лексем"),
		ERROR_ENTRY(203, "Лексическая ошибка: Превышен размер таблицы идентификаторов"),
		ERROR_ENTRY(204, "Лексическая ошибка: Превышен максимальный размер исходного файла"),
		ERROR_ENTRY(205, "Лексическая ошибка: Отсутствует ключевое слово main перед телом программы"),
		#pragma region C
		ERROR_ENTRY_NODEF(206), ERROR_ENTRY_NODEF(207), ERROR_ENTRY_NODEF(208), ERROR_ENTRY_NODEF(209),
		ERROR_ENTRY_NODEF10(210), ERROR_ENTRY_NODEF10(220), ERROR_ENTRY_NODEF10(230), ERROR_ENTRY_NODEF10(240),
		ERROR_ENTRY_NODEF10(250), ERROR_ENTRY_NODEF10(260), ERROR_ENTRY_NODEF10(270), ERROR_ENTRY_NODEF10(280), ERROR_ENTRY_NODEF10(290),
		#pragma endregion C
		ERROR_ENTRY(300, "Семантическая ошибка: Необъявленный идентификатор"),
		ERROR_ENTRY(301, "Семантическая ошибка: Отсутствует точка входа main"),
		ERROR_ENTRY(302, "Семантическая ошибка: Обнаружено несколько точек входа main"),
		ERROR_ENTRY(303, "Семантическая ошибка: В объявлении не указан тип идентификатора"),
		ERROR_ENTRY(304, "Семантическая ошибка: В объявлении отсутствует ключевое слово type"),
		ERROR_ENTRY(305, "Семантическая ошибка: Попытка переопределения идентификатора"),
		ERROR_ENTRY(306, "Семантическая ошибка: Превышено максимальное количество параметров функции"),
		ERROR_ENTRY(307, "Семантическая ошибка: Слишком много параметров в вызове"),
		ERROR_ENTRY_NODEF(308),
		ERROR_ENTRY(309, "Семантическая ошибка: Несовпадение типов передаваемых параметров"),
		ERROR_ENTRY(310, "Семантическая ошибка: Использование пустого строкового литерала недопустимо"),
		ERROR_ENTRY(311, "Семантическая ошибка: Обнаружен символ \'\"\'. Возможно, не закрыт строковый литерал"),
		ERROR_ENTRY(312, "Семантическая ошибка: Превышен размер строкового литерала"),
		ERROR_ENTRY(313, "Семантическая ошибка: Недопустимый целочисленный литерал"),
		ERROR_ENTRY(314, "Семантическая ошибка: Типы данных в выражении не совпадают"),
		ERROR_ENTRY(315, "Семантическая ошибка: Недопустимое строковое выражение справа от знака \'=\'"),
		ERROR_ENTRY_NODEF(316),
		ERROR_ENTRY(317, "Семантическая ошибка: Деление на ноль"),
		ERROR_ENTRY(318, "Семантическая ошибка: Недопустимое имя переменной - использование ключевого слова"),
		#pragma region D
		ERROR_ENTRY_NODEF(319), ERROR_ENTRY_NODEF(320),
		ERROR_ENTRY_NODEF(321), ERROR_ENTRY_NODEF(322), ERROR_ENTRY_NODEF(323), ERROR_ENTRY_NODEF(324), ERROR_ENTRY_NODEF(325),
		ERROR_ENTRY_NODEF(326),	ERROR_ENTRY_NODEF(327), ERROR_ENTRY_NODEF(328), ERROR_ENTRY_NODEF(329),
		ERROR_ENTRY_NODEF10(330),ERROR_ENTRY_NODEF10(340),ERROR_ENTRY_NODEF10(350),
		ERROR_ENTRY_NODEF10(360),ERROR_ENTRY_NODEF10(370),ERROR_ENTRY_NODEF10(380),ERROR_ENTRY_NODEF10(390),
		ERROR_ENTRY_NODEF100(400), ERROR_ENTRY_NODEF100(500),
		#pragma endregion D
		ERROR_ENTRY(600, "Синтаксическая ошибка: Неверная структура программы"),
		ERROR_ENTRY(601, "Синтаксическая ошибка: Не найден список параметров функции"),
		ERROR_ENTRY(602, "Синтаксическая ошибка: Ошибка в теле функции"),
		ERROR_ENTRY_NODEF(603),
		ERROR_ENTRY(604, "Синтаксическая ошибка: Ошибка в списке фактических параметров функции"),
		ERROR_ENTRY(605, "Синтаксическая ошибка: Ошибка в условии цикла/условного выражения"),
		ERROR_ENTRY_NODEF(606), ERROR_ENTRY_NODEF(607), ERROR_ENTRY_NODEF(608), ERROR_ENTRY_NODEF(609),
		ERROR_ENTRY(610, "Синтаксическая ошибка: Неверный арифметический оператор"),
		ERROR_ENTRY(611, "Синтаксическая ошибка: Ошибка в арифметическом выражении"),
		ERROR_ENTRY(612, "Синтаксическая ошибка: Недопустимая синтаксическая конструкция"),
		ERROR_ENTRY_NODEF(613),
		ERROR_ENTRY_NODEF(614),
		ERROR_ENTRY(615, "Синтаксическая ошибка: Ожидался литерал или идентификатор"),
		ERROR_ENTRY_NODEF(616),
		ERROR_ENTRY(617, "Синтаксическая ошибка: Ошибка в теле цикла"),
		ERROR_ENTRY(618, "Синтаксическая ошибка: Отсутствует закрывающая фигурная скобка"),
		ERROR_ENTRY_NODEF(619),
		ERROR_ENTRY_NODEF10(620), ERROR_ENTRY_NODEF10(630), ERROR_ENTRY_NODEF10(640), ERROR_ENTRY_NODEF10(650),
		ERROR_ENTRY_NODEF10(660), ERROR_ENTRY_NODEF10(670), ERROR_ENTRY_NODEF10(680), ERROR_ENTRY_NODEF10(690),
		ERROR_ENTRY_NODEF100(700), ERROR_ENTRY_NODEF100(800), ERROR_ENTRY_NODEF100(900)
	};
	ERROR geterror(int id)
	{
		ERROR error_info;												// создание структуры которую надо будет вернуть
		if (id > 0 && id < ERROR_MAX_ENTRY)						// сравнивание диапазона
		{
			error_info.id = errors[id].id;
			strcpy_s(error_info.message, errors[id].message);
			error_info.position.col = -1;
			error_info.position.line = -1;
		}
		else
		{
			error_info.id = errors[0].id;
			strcpy_s(error_info.message, errors[0].message);
		}
		return error_info;
	}
	ERROR geterrorin(int id, int line, int col)
	{
		ERROR error_info;												//	создание структуру которую надо будет вернуть
		if (id > 0 && id < ERROR_MAX_ENTRY)						// сравнение диапазона
		{
			error_info.id = errors[id].id;
			error_info.position.col = col;
			error_info.position.line = line;
			strcpy_s(error_info.message, errors[id].message);
			return error_info;
		}
		else
		{
			error_info.id = 0; // заношу
			error_info.position.col = -1;
			error_info.position.line = -1;
			strcpy_s(error_info.message, errors[0].message);
			return error_info;
		}
	}
	;
};

file FST.cpp:
#include "pch.h"
#include <climits>

#include <iostream>


namespace FST
{
	RELATION::RELATION(unsigned char c, short nn)
	{
		symbol = c;
		nnode = nn;
	};

	NODE::NODE()
	{
		n_relation = 0;
		relations = nullptr;
	};

	NODE::NODE(short n, RELATION rel, ...)
	{
		n_relation = n;
		RELATION *p = &rel;
		relations = new RELATION[n];

		for (short i = 0; i < n; i++)
		{
			relations[i] = p[i];
		}
	};

		FST::FST(short ns, NODE n, ...)
		{
			nodes = new NODE[ns];
			NODE* temp = &n;
			nstates = ns;
			rstates = new short[ns];
			for (short i = 0; i < ns; i++)
				nodes[i] = *(temp + i);
			rstates[0] = 0;
			position = -1;
		}
	
		FST::FST(unsigned char* s, FST& fst)
		{
			nodes = new NODE[fst.nstates];
			NODE* temp = fst.nodes;
			string = s;
			nstates = fst.nstates;
			rstates = new short[nstates];
			for (short i = 0; i < nstates; i++)
				nodes[i] = *(temp + i);
			rstates[0] = 0;
			position = -1;
		}
	bool step(FST& fst, short* &rstates)
	{
		bool rc = false;
		std::swap(rstates, fst.rstates);
		for (short i = 0; i < fst.nstates; i++)
		{
			if (rstates[i] == fst.position)
				for (short j = 0; j < fst.nodes[i].n_relation; j++)
				{
					if (fst.nodes[i].relations[j].symbol == fst.string[fst.position])
					{
						fst.rstates[fst.nodes[i].relations[j].nnode] = fst.position + 1;
						rc = true;
					};
				};
		};
		return rc;
	};
	bool execute(FST& fst)
	{
		short* rstates = new short[fst.nstates];
		memset(rstates, 0xff, sizeof(short)*fst.nstates);
		size_t lstring_size = _mbslen(fst.string);
		short lstring = (lstring_size <= SHRT_MAX) ? static_cast<short>(lstring_size) : SHRT_MAX;
		bool rc = true;
		for (short i = 0; i < lstring && rc; i++)
		{
			fst.position++;
			rc = step(fst, rstates);
		};
		delete[] rstates;
		return (rc ? (fst.rstates[fst.nstates - 1] == lstring) : rc);
	};


}

file Generator.cpp:
#include "pch.h"
#include <string>
#include <vector>

using namespace std;

namespace Gener
{

	bool CodeGeneration(Lex::LEX& lex, Parm::PARM& parm, Log::LOG& log)
	{
		bool gen_ok = true;
		ofstream ofile(parm.out);
		ofile << BEGIN;
		ofile << EXTERN;
		ofile << ".const\n null_division BYTE 'ERROR: DIVISION BY ZERO', 0\n overflow BYTE 'ERROR: VARIABLE OVERFLOW', 0 \n";
		int conditionnum = 0, cyclenum = 0;
		for (int i = 0; i < lex.idtable.size; i++)
		{
			if (lex.idtable.table[i].idtype == IT::L)
			{
				ofile << "\t" << lex.idtable.table[i].id;
				if (lex.idtable.table[i].iddatatype == IT::SYM)
				{
					ofile << " BYTE \'" << lex.idtable.table[i].value.symbol << "\', 0\n";
				}
				if (lex.idtable.table[i].iddatatype == IT::STR)
				{
					ofile << " BYTE \'" << lex.idtable.table[i].value.vstr.str << "\', 0\n";
				}
				if (lex.idtable.table[i].iddatatype == IT::INT)
				{
					ofile << " SWORD " << lex.idtable.table[i].value.vint << endl;
				}
			}
		}
		ofile << ".data\n";
		for (int i = 0; i < lex.idtable.size; i++)
		{
			if (lex.idtable.table[i].idtype == IT::IDTYPE::V)
			{
				ofile << "\t" << lex.idtable.table[i].id;
				if (lex.idtable.table[i].iddatatype == IT::SYM)
				{
					ofile << " DWORD ?\n";
				}
				if (lex.idtable.table[i].iddatatype == IT::STR)
				{
					ofile << " DWORD ?\n";
				}
				if (lex.idtable.table[i].iddatatype == IT::INT)
				{
					ofile << " SWORD 0\n";
				}
			}
		}

		stack<string> stk;
		stack<IT::Entry> temp;
		string cyclecode = "", func_name = "";					// имя локальной функции
		bool flag_cycle = false,					// внутри цикла?
			flag_main = false,
			flag_is = false,					// is
			flag_true = false,
			flag_false = false,
			flag_return = false;

		ofile << "\n.code\n\n";
		for (int i = 0; i < lex.lextable.size; i++)
		{
			switch (lex.lextable.table[i].lexema)
			{
			case LEX_FUNCTION:
			{
				i++;
				flag_return = false;
				ofile << (func_name = ITENTRY(i).id) << " PROC ";
				int j = i + 2;
				while (LEXEMA(j) != LEX_RIGHTTHESIS) // пока параметры не кончатся
				{
					if (lex.lextable.table[j].lexema == LEX_ID) // параметр
					{
						ofile << lex.idtable.table[lex.lextable.table[j].idxTI].id << " : ";
						if (ITENTRY(j).iddatatype == IT::IDDATATYPE::INT)
						{
							ofile << " SWORD ";
						}
						else if (ITENTRY(j).iddatatype == IT::IDDATATYPE::SYM)
						{
							ofile << " DWORD ";
						}
						else
						{
							ofile << " DWORD ";
						}
					}
					if (LEXEMA(j) == LEX_COMMA)
					{
						ofile << ", ";
					}
					j++;
				}
				ofile << endl;
				break;
			}
			case LEX_MAIN:
			{
				flag_main = true;
				ofile << "main PROC\n";
				break;
			}
			case LEX_RETURN:
			{
				// Проверка return в main была удалена (ошибка 320 больше не используется)
				// if (flag_main) { ... }
				if (LEXEMA(i + 1) != LEX_SEPARATOR)
				{
					if (LEXEMA(i + 1) != LEX_LEFTHESIS && (ITENTRY(i + 1).iddatatype == IT::IDDATATYPE::INT || ITENTRY(i + 1).idtype == IT::IDTYPE::P || ITENTRY(i + 1).idtype == IT::IDTYPE::V))
						ofile << "\tmov eax, " << ITENTRY(i + 1).id << "\n";
					else if (LEXEMA(i + 1) != LEX_LEFTHESIS)
						ofile << "\tmov eax,offset " << ITENTRY(i + 1).id << "\n";
					else if (LEXEMA(i + 2) != LEX_MINUS)
						ofile << "\tmov eax, " << ITENTRY(i + 2).id << "\n";
					else
					{
						ofile << "\tmov eax, 0\n";
						ofile << "\tmov ebx," << ITENTRY(i + 3).id;
						ofile << "\n\tsub eax, ebx\n";
					}
				}
				ofile << "\tret\n";
				if (!flag_return)
				{
					ofile << "\nSOMETHINGWRONG:"\
						"\npush offset null_division"\
						"\ncall outstrline\n"\
						"call system_pause"\
						"\npush -1"\
						"\ncall ExitProcess\n"\
						"\nEXIT_OVERFLOW:"\
						"\npush offset overflow"\
						"\ncall outstrline\n"\
						"call system_pause"\
						"\npush -2"\
						"\ncall ExitProcess\n";
					flag_return = true;
				}
				break;
			}
			case LEX_BRACELET:
			{
				if (flag_main)
					break;
				ofile << func_name + " ENDP\n";
				break;
			}
			case LEX_EQUAL:
			{
				int result_position = i - 1;
				// Проверяем, является ли это простым присваиванием литерала
				bool isSimpleLiteralAssignment = false;
				int expr_start = i;
				int next_separator = i;
				while (lex.lextable.table[next_separator].lexema != LEX_SEPARATOR)
					next_separator++;
				// Проверяем, что между = и ; только один токен - литерал
				if (next_separator - expr_start == 2 && LEXEMA(i + 1) == LEX_LITERAL && ITENTRY(i + 1).iddatatype == IT::IDDATATYPE::INT)
				{
					isSimpleLiteralAssignment = true;
					// Для простого присваивания литерала генерируем прямое присваивание
					ofile << "\tmov word ptr " << ITENTRY(result_position).id << ", " << ITENTRY(i + 1).value.vint << endl;
					i = next_separator; // Пропускаем остальную обработку
					break;
				}

				while (lex.lextable.table[i].lexema != LEX_SEPARATOR)
				{

					switch (LEXEMA(i))
					{
					case LEX_STDFUNC:
					case LEX_LITERAL:
					{
						// Проверяем, является ли это именем функции (не параметром)
						bool isFunctionName = (ITENTRY(i).idtype == IT::IDTYPE::F || ITENTRY(i).idtype == IT::IDTYPE::S);
						if (isFunctionName)
						{
							// Имя функции не пушим в стек, оно будет использовано в LEX_SUBST
							break;
						}
						if (ITENTRY(i).iddatatype == IT::IDDATATYPE::INT)
						{
							ofile << "\tmovsx eax, word ptr " << ITENTRY(i).id << endl;
							ofile << "\tpush eax" << endl;
							stk.push(lex.idtable.table[lex.lextable.table[i].idxTI].id);
							break;
						}
						else
						{
							ofile << "\tpush offset " << ITENTRY(i).id << endl;
							stk.push("offset" + (string)lex.idtable.table[lex.lextable.table[i].idxTI].id);
							break;
						}
					}
					case LEX_ID:
					{
						// Проверяем, является ли это именем функции (не параметром)
						bool isFunctionName = (ITENTRY(i).idtype == IT::IDTYPE::F || ITENTRY(i).idtype == IT::IDTYPE::S);
						if (isFunctionName)
						{
							// Имя функции не пушим в стек, оно будет использовано в LEX_SUBST
							break;
						}
						if (ITENTRY(i).idtype == IT::IDTYPE::V && ITENTRY(i).iddatatype == IT::IDDATATYPE::INT)
						{
							// Для целочисленных переменных используем movsx для правильного расширения
							ofile << "\tmovsx eax, word ptr " << ITENTRY(i).id << endl;
							ofile << "\tpush eax" << endl;
						}
						else
							ofile << "\tpush " << ITENTRY(i).id << endl;
						stk.push(lex.idtable.table[lex.lextable.table[i].idxTI].id);
						break;
					}
					case LEX_SUBST:
					{
						// В польской нотации порядок: параметры, @, количество, имя_функции
						// Количество параметров находится сразу после @ (LEX_SUBST)
						// Ищем количество параметров в таблице лексем
						int param_count = 0;
						
						// Сначала проверяем позицию i + 1 (стандартное место)
						if (i + 1 < lex.lextable.size)
						{
							char count_char = lex.lextable.table[i + 1].lexema;
							if (count_char >= '0' && count_char <= '9')
							{
								param_count = count_char - '0';
							}
						}
						
						// Если не нашли в стандартном месте, ищем символ '0'-'9' в ближайших позициях
						if (param_count <= 0 || param_count > 5)
						{
							for (int k = i + 1; k < lex.lextable.size && k <= i + 5; k++)
							{
								if (lex.lextable.table[k].lexema == LEX_SEPARATOR)
									break;
								char count_char = lex.lextable.table[k].lexema;
								if (count_char >= '0' && count_char <= '9')
								{
									int candidate = count_char - '0';
									if (candidate > 0 && candidate <= 5)
									{
										param_count = candidate;
										break;
									}
								}
							}
						}
						
						// Если все еще не нашли, используем размер стека строк как последний fallback
						if (param_count <= 0 || param_count > 5)
						{
							int stack_size = (int)stk.size();
							if (stack_size > 0 && stack_size <= 5)
							{
								param_count = stack_size;
							}
							else
							{
								// Значение по умолчанию для стандартных функций
								param_count = 2; // pow, random, compare имеют 2 параметра
							}
						}
						
						// Финальная валидация
						if (param_count > 5)
							param_count = 5;
						if (param_count <= 0)
							param_count = 1;
						// Ищем имя функции, идя назад от позиции LEX_SUBST
						// В польской нотации: параметры, @, количество, имя_функции
						// Нужно найти функцию, которая идет после количества параметров
						string func_name = "";
						// Ищем функцию после позиции количества параметров (i + 1)
						// Функция должна быть после всех параметров и после @
						for (int k = i + 2; k < lex.lextable.size && k <= i + 20; k++) // Ищем вперед после @ и количества
						{
							if (lex.lextable.table[k].lexema == LEX_SEPARATOR)
								break;
							if (lex.lextable.table[k].idxTI != TI_NULLIDX &&
								(ITENTRY(k).idtype == IT::IDTYPE::F || ITENTRY(k).idtype == IT::IDTYPE::S))
							{
								func_name = ITENTRY(k).id;
								break;
							}
						}
						// Если не нашли вперед, ищем назад (старый способ)
						if (func_name.empty())
						{
							for (int k = i - 1; k >= 0 && k >= i - 20; k--)
							{
								if (k < 0 || lex.lextable.table[k].lexema == LEX_SEPARATOR)
									break;
								if (lex.lextable.table[k].idxTI != TI_NULLIDX &&
									(ITENTRY(k).idtype == IT::IDTYPE::F || ITENTRY(k).idtype == IT::IDTYPE::S))
								{
									// Проверяем, что это не уже обработанный вызов функции
									// (не должен быть между текущей позицией и предыдущим LEX_SUBST)
									bool isAlreadyProcessed = false;
									for (int m = k + 1; m < i; m++)
						{
										if (lex.lextable.table[m].lexema == LEX_SUBST)
										{
											isAlreadyProcessed = true;
											break;
										}
									}
									if (!isAlreadyProcessed)
									{
										func_name = ITENTRY(k).id;
										break;
									}
								}
							}
						}
						// Если все еще не нашли, используем старый метод как последний fallback
						if (func_name.empty() && i - param_count - 1 >= 0 && lex.lextable.table[i - param_count - 1].idxTI != TI_NULLIDX)
						{
							// Проверяем, что это действительно функция, а не литерал
							if (ITENTRY(i - param_count - 1).idtype == IT::IDTYPE::F || ITENTRY(i - param_count - 1).idtype == IT::IDTYPE::S)
							{
								func_name = ITENTRY(i - param_count - 1).id;
							}
						}
					// Если все еще не нашли, это ошибка (используем общую ошибку генерации)
					if (func_name.empty())
					{
						// Функция не найдена - это внутренняя ошибка генератора
						// Log::WriteError(log.stream, Error::geterrorin(320, lex.lextable.table[i].sn, 0));
						ofile.close();
						return false;
					}
						// Определяем, являются ли параметры строковыми (для функций compare, lenght)
						bool is_string_func = (func_name == "compare" || func_name == "lenght");
						
						// ВАЖНО: Сохраняем размер стека строк ДО извлечения параметров
						// Стек строк должен содержать только параметры текущего вызова функции
						int actual_param_count = (int)stk.size();
						
						// Для стандартных функций знаем точное количество параметров
						// Используем это знание для валидации
						int expected_param_count = 0;
						if (func_name == "power" || func_name == "pow")
							expected_param_count = 2;
						else if (func_name == "random")
							expected_param_count = 2;
						else if (func_name == "compare")
							expected_param_count = 2;
						else if (func_name == "lenght")
							expected_param_count = 1;
						
						// Если знаем ожидаемое количество параметров, используем его
						if (expected_param_count > 0)
						{
							param_count = expected_param_count;
						}
						// Иначе, если размер стека строк разумный и не совпадает с значением из таблицы,
						// используем размер стека строк (но только если значение из таблицы явно неправильное)
						else if (actual_param_count > 0 && actual_param_count <= 5 && 
							(param_count <= 0 || param_count > 5 || (param_count != actual_param_count && actual_param_count < param_count)))
						{
							// Используем фактический размер стека строк, если он меньше значения из таблицы
							// (это означает, что значение из таблицы может быть неправильным)
							param_count = actual_param_count;
						}
						
						// Сохраняем идентификаторы параметров из стека строк
						vector<string> params;
						for (int j = 0; j < param_count; j++)
						{
							if (!stk.empty())
							{
								params.push_back(stk.top());
							stk.pop();
						}
						}
						// Параметры уже находятся на стеке значений в порядке их обработки
						// В польской нотации: param1, param2, @, count, func_name
						// На стеке: param1 (внизу), param2 (сверху) - последний параметр сверху
						// Для __stdcall нужно: push param2, push param1 (справа налево)
						// Сохраняем параметры со стека в регистры в обратном порядке
						// (чтобы потом пушить в правильном порядке для __stdcall)
						if (param_count == 1)
						{
							// Один параметр - просто оставляем на стеке
							// (уже в правильном порядке)
						}
						else if (param_count == 2)
						{
							// Два параметра: сохраняем оба, затем пушим в обратном порядке
							ofile << "\tpop edx\n"; // Второй параметр (последний)
							ofile << "\tpop ecx\n"; // Первый параметр
							ofile << "\tpush edx\n"; // Пушим второй параметр первым (справа)
							ofile << "\tpush ecx\n"; // Пушим первый параметр вторым (слева)
						}
						else
						{
							// Больше двух параметров - используем общий подход
							// Сохраняем все параметры
							for (int j = param_count - 1; j >= 0; j--)
							{
								if (j == param_count - 1)
									ofile << "\tpop ecx\n";
								else if (j == param_count - 2)
									ofile << "\tpop edx\n";
								else if (j == param_count - 3)
									ofile << "\tpop esi\n";
								else
									ofile << "\tpop edi\n"; // Для 4+ параметров
							}
							// Пушим в обратном порядке (справа налево для __stdcall)
							for (int j = param_count - 1; j >= 0; j--)
							{
								if (j == param_count - 1)
									ofile << "\tpush ecx\n";
								else if (j == param_count - 2)
									ofile << "\tpush edx\n";
								else if (j == param_count - 3)
									ofile << "\tpush esi\n";
								else
									ofile << "\tpush edi\n";
							}
						}
						ofile << "\t\tcall " << func_name << "\n\tpush eax\n";
						break;
					}
					case LEX_TILDA:
					{
						ofile << "\tmov eax, 0\n\tpop ebx\n";
						ofile << "\tsub eax, ebx\n\tpush eax\n";
						break;
					}
					case LEX_STAR:
					{
						ofile << "\tpop ebx\n\tpop eax\n";
						ofile << "\timul ebx\n\tpush eax\n";

						break;
					}

					case LEX_PLUS:
					{
						ofile << "\tpop ebx\n\tpop eax\n";
						ofile << "\tadd eax, ebx\n\tpush eax\n";
						break;
					}
					case LEX_MINUS:
					{
						if (LEXEMA(i - 2) == LEX_EQUAL)
						{
							ofile << "\tmov eax, 0\n\tpop ebx\n";
							ofile << "\tsub eax, ebx\n\tpush eax\n";
							break;
						}
						ofile << "\tpop ebx\n\tpop eax\n";
						ofile << "\tsub eax, ebx\n\tpush eax\n";
						break;
					}
					case LEX_DIRSLASH:
					{
						ofile << "\tpop ebx\n\tpop eax\n";
						ofile << "\tcmp ebx,0\n"\
							"\tje SOMETHINGWRONG\n";
						ofile << "\tcdq\n";
						ofile << "\tidiv ebx\n\tpush eax\n";
						break;
					}
					case LEX_PROCENT:
					{

						ofile << "\tpop ebx\n\tpop eax\n";
						ofile << "\tcmp ebx,0\n"\
							"\tje SOMETHINGWRONG\n";
						ofile << "\tcdq\n";
						ofile << "\tidiv ebx\n\tpush edx\n";
						break;
					}
					}
					i++;
				}
				if (ITENTRY(result_position).idtype == IT::IDTYPE::V && ITENTRY(result_position).iddatatype == IT::IDDATATYPE::INT)
				{
					ofile << "\tpop eax\n";
					ofile << "\tmov word ptr " << ITENTRY(result_position).id << ", ax\n";
				}
				else
					ofile << "\tpop " << ITENTRY(result_position).id << "\n";
				ofile << endl;
				break;
			}
			case LEX_ID:
			{
				if (LEXEMA(i + 1) == LEX_LEFTHESIS && LEXEMA(i - 1) != LEX_FUNCTION
					&& lex.lextable.table[i].sn > lex.lextable.table[i - 1].sn)
				{
					// Обработка вызова функции - параметры будут обработаны в LEX_SUBST
					// Здесь просто пропускаем, чтобы не дублировать код
				}
				break;
			}
				case LEX_INCR:
				{
					ofile << "\tmov eax," << ITENTRY(i - 1).id << "\n";
					ofile << "\tmov ebx," << ITENTRY(i + 1).id << "\n";
					switch (ITENTRY(i).id[1])
					{
					case LEX_PLUS:
					{
						ofile << "\tadd eax, ebx\n";
						break;
					}
					case LEX_MINUS:
					{
						ofile << "\tsub eax, ebx\n";
						break;
					}
					case LEX_STAR:
					{
						ofile << "\timul ebx\n";
						break;
					}
					case LEX_DIRSLASH:
					{
						ofile << "\tcmp ebx,0\n"\
							"\tje SOMETHINGWRONG\n";
						ofile << "\tcdq\n";
						ofile << "\tidiv ebx\n";
						break;
					}
					}
					ofile << "\tmov " << ITENTRY(i - 1).id << " , eax\n";
					break;
				}
			case LEX_NEWLINE: // перевод строки 
			{
				switch (ITENTRY(i + 1).iddatatype)
				{
				case IT::IDDATATYPE::INT:
					if (ITENTRY(i + 1).idtype == IT::IDTYPE::V || ITENTRY(i + 1).idtype == IT::IDTYPE::P)
						ofile << "\n\tmovsx eax, word ptr " << ITENTRY(i + 1).id << "\n\tpush eax\ncall outnumline\n";
					else
						ofile << "\npush " << ITENTRY(i + 1).id << "\ncall outnumline\n";
					break;
				case IT::IDDATATYPE::SYM:
				case IT::IDDATATYPE::STR:
					if (ITENTRY(i + 1).idtype == IT::IDTYPE::L)
						ofile << "\npush offset " << ITENTRY(i + 1).id << "\ncall outstrline\n";
					else ofile << "\npush " << ITENTRY(i + 1).id << "\ncall outstrline\n";
					break;
				}
				break;
			}
			case LEX_WRITE: // вывод
			{
				switch (ITENTRY(i + 1).iddatatype)
				{
				case IT::IDDATATYPE::INT:
					if (ITENTRY(i + 1).idtype == IT::IDTYPE::V || ITENTRY(i + 1).idtype == IT::IDTYPE::P)
						ofile << "\n\tmovsx eax, word ptr " << ITENTRY(i + 1).id << "\n\tpush eax\ncall outnum\n";
					else
						ofile << "\npush " << ITENTRY(i + 1).id << "\ncall outnum\n";
					break;
				case IT::IDDATATYPE::SYM:
				case IT::IDDATATYPE::STR:
					if (ITENTRY(i + 1).idtype == IT::IDTYPE::L)
						ofile << "\npush offset " << ITENTRY(i + 1).id << "\ncall outstr\n";
					else ofile << "\npush " << ITENTRY(i + 1).id << "\ncall outstr\n";
					break;
				}
				break;
			}
			case LEX_IS: // условие
			{
				conditionnum++;
				flag_is = true;
				const char* right = "jz", * wrong = "jnz"; // Исправлено на const char*, инициализированы значениями по умолчанию
				int j = i;
				while (LEXEMA(j) != LEX_SQ_RBRACELET)
				{
					if (LEXEMA(j) == LEX_ISTRUE)
					{
						flag_true = true;
					}
					else if (LEXEMA(j) == LEX_ISFALSE)
					{
						flag_false = true;
					}
					j++;
				}
				if (LEXEMA(j + 1) == LEX_ISTRUE || LEXEMA(j + 1) == LEX_ISFALSE)
				{
					flag_true = true;
					flag_false = true;
				}
				switch (LEXEMA(i + 2))
				{
				case LEX_MORE:
					right = "jg";  wrong = "jle";
					break;
				case LEX_LESS:
					right = "jl";  wrong = "jge";
					break;
				case LEX_EQUALS:
					right = "jz";  wrong = "jnz";
					break;
				case LEX_NOTEQUALS:
					right = "jnz";  wrong = "jz";
					break;
				}
				if (ITENTRY(i + 1).iddatatype == IT::IDDATATYPE::INT)
				{
					ofile << "\tmov edx, " << ITENTRY(i + 1).id << "\n\tcmp edx, " << ITENTRY(i + 3).id << "\n";


				}
				if (ITENTRY(i + 1).iddatatype == IT::IDDATATYPE::SYM || ITENTRY(i + 1).iddatatype == IT::IDDATATYPE::STR)
				{
					if (ITENTRY(i + 1).idtype == IT::IDTYPE::V || ITENTRY(i + 1).idtype == IT::IDTYPE::P)
						ofile << "\n\tmov esi, " << ITENTRY(i + 1).id;
					else
						ofile << "\n\tmov esi, offset " << ITENTRY(i + 1).id;

					if (ITENTRY(i + 3).idtype == IT::IDTYPE::V || ITENTRY(i + 3).idtype == IT::IDTYPE::P)
						ofile << "\n\tmov edi, " << ITENTRY(i + 3).id;
					else
						ofile << "\n\tmov edi, offset " << ITENTRY(i + 3).id;

					if (ITENTRY(i + 1).idtype == IT::IDTYPE::V || ITENTRY(i + 1).idtype == IT::IDTYPE::P)
						ofile << "\n\t push " << ITENTRY(i + 1).id;
					else
						ofile << "\n\t push offset " << ITENTRY(i + 1).id;

					ofile << "\n\t call lenght";
					ofile << "\n\t mov ebx,eax";

					if (ITENTRY(i + 1).idtype == IT::IDTYPE::V || ITENTRY(i + 3).idtype == IT::IDTYPE::P)
						ofile << "\n\t push " << ITENTRY(i + 3).id;
					else
						ofile << "\n\t push offset " << ITENTRY(i + 3).id;

					ofile << "\n\t call lenght";
					ofile << "\n\t cmp ebx,eax";
					if (flag_false)
						ofile << "\n\t" << wrong << " wrong" << conditionnum;
					else
						ofile << "\n\t jne next" << conditionnum;
					ofile << "\n\t mov ecx,eax";
					ofile << "\n\t repe cmpsb\n";
				}
				if (flag_true)
					ofile << "\t" << right << " right" << conditionnum << "\n";
				if (flag_false)
					ofile << "\t" << wrong << " wrong" << conditionnum << "\n";
				ofile << "\t" << "jmp next" << conditionnum << "\n";
				i += 2;
				break;
			}
			case LEX_ISTRUE:
			{
				ofile << "right" << conditionnum << ":";
				break;
			}
			case LEX_ISFALSE:
			{
				ofile << "wrong" << conditionnum << ":";
				break;
			}
			case LEX_SQ_RBRACELET:
			{
				if (flag_cycle)
				{
					// Проверяем, это repeat цикл или while
					bool isRepeat = false;
					for (int k = i; k >= 0 && k > i - 50; k--)
					{
						if (LEXEMA(k) == LEX_REPEAT)
						{
							isRepeat = true;
							break;
						}
					}
					if (isRepeat)
					{
						// Для repeat цикла - декремент счетчика и проверка
						ofile << "\tdec esi\n";  // Уменьшаем счетчик
						ofile << "\tcmp esi, 0\n";  // Проверяем
						ofile << "\tjne cycle" << cyclenum << "\n";  // Если esi != 0, продолжить цикл
						ofile << "continue" << cyclenum << ":\n";
					}
					else
					{
						// Для while цикла
						ofile << cyclecode;
						ofile << "continue" << cyclenum << ":";
					}
					flag_cycle = false;
				}
				if (flag_is)
				{
					if (LEXEMA(i + 1) != LEX_ISTRUE && LEXEMA(i + 1) != LEX_ISFALSE)
					{
						ofile << "\nnext" << conditionnum << ":";
						flag_is = false;
						flag_true = false;
						flag_false = false;
					}
					else
					{
						ofile << "\tjmp next" << conditionnum << "\n\n";
					}
				}
				break;
			}
			case LEX_WHILE:
			{
				flag_cycle = true;
				cyclecode.clear();
				cyclenum++;
				const char* right = "jz", * wrong = "jnz"; // Исправлено на const char*, инициализированы значениями по умолчанию
				switch (LEXEMA(i + 2))
				{
				case LEX_MORE:
					right = "jg";  wrong = "jle";
					break;
				case LEX_LESS:
					right = "jl";  wrong = "jge";
					break;
				case LEX_EQUALS:
					right = "jz";  wrong = "jnz";
					break;
				case LEX_NOTEQUALS:
					right = "jnz";  wrong = "jz";
					break;
				}
				if (ITENTRY(i + 1).iddatatype == IT::IDDATATYPE::INT)
				{
					cyclecode = "\tmov edx, " + (string)ITENTRY(i + 1).id + "\n\tcmp edx, " + (string)ITENTRY(i + 3).id + "\n";
				}
				if (ITENTRY(i + 1).iddatatype == IT::IDDATATYPE::SYM || ITENTRY(i + 1).iddatatype == IT::IDDATATYPE::STR)
				{
					if (ITENTRY(i + 1).idtype == IT::IDTYPE::V || ITENTRY(i + 1).idtype == IT::IDTYPE::P)
						cyclecode += "\tmov esi, " + (string)ITENTRY(i + 1).id;
					else
						cyclecode += "\tmov esi, offset" + (string)ITENTRY(i + 1).id;
					if (ITENTRY(i + 3).idtype == IT::IDTYPE::V || ITENTRY(i + 3).idtype == IT::IDTYPE::P)
						cyclecode += "\n\tmov edi, " + (string)ITENTRY(i + 3).id + "\n";
					else
						cyclecode += "\n\tmov edi, offset" + (string)ITENTRY(i + 3).id + "\n";

					if (ITENTRY(i + 1).idtype == IT::IDTYPE::V || ITENTRY(i + 1).idtype == IT::IDTYPE::P)
						cyclecode += "\n\t push " + (string)ITENTRY(i + 1).id;
					else
						cyclecode += "\n\t push offset" + (string)ITENTRY(i + 1).id;

					cyclecode += "\n\t call lenght";
					cyclecode += "\n\t mov ebx,eax";

					if (ITENTRY(i + 3).idtype == IT::IDTYPE::V || ITENTRY(i + 3).idtype == IT::IDTYPE::P)
						cyclecode += "\n\t push " + (string)ITENTRY(i + 3).id;
					else
						cyclecode += "\n\t push offset" + (string)ITENTRY(i + 3).id;
					cyclecode += "\n\t call lenght";
					cyclecode += "\n\t cmp ebx,eax";
					cyclecode += "\n\t" + (string)wrong + " continue" + std::to_string(cyclenum);
					cyclecode += "\n\t mov ecx,eax";
					cyclecode += "\n\t repe cmpsb\n";
				}
				cyclecode += "\t" + (string)right + " cycle" + std::to_string(cyclenum) + "\n";
				ofile << cyclecode;
				ofile << "\t" << "jmp continue" << cyclenum << "\n";
				i += 2;
				break;
			}
			case LEX_DO:
			{
				// Метка cycleN генерируется только для while циклов, для repeat циклов она уже сгенерирована в LEX_REPEAT
				// Для repeat циклов здесь ничего не делаем
				break;
			}
			case LEX_REPEAT:
			{
				flag_cycle = true;
				cyclecode.clear();
				cyclenum++;
				// repeat <число> times do [ ... ]
				// i+1 - литерал с числом повторений
				short repeatCount = ITENTRY(i + 1).value.vint;
				ofile << "\tmov esi, " << repeatCount << "\n"; // счетчик цикла в esi (редко используется в операциях)
				ofile << "cycle" << cyclenum << ":\n";
				// Проверка будет в конце цикла
				break;
			}
			case LEX_TIMES:
			{
				// times - просто маркер, обработка уже в repeat
				break;
			}

			}
		}
		ofile << END;
		ofile.flush(); // Принудительная запись буфера
		ofile.close();
		return true;
	};
}

file Greibach.cpp:
#include "pch.h"
#include "Rule.h"

namespace GRB
{

	Rule::Chain::Chain(short psize, GRBALPHABET s, ...)	// конструктор для записи символов в цепочку
	{
		nt = new GRBALPHABET[size = psize];
		int* p = (int*)&s;
		for (short i = 0; i < psize; ++i)
			nt[i] = (GRBALPHABET)p[i];
	};

	Rule::Rule(GRBALPHABET pnn, int piderror, short psize, Chain c, ...) // конструктор
	{
		nn = pnn;
		iderror = piderror;
		chains = new Chain[size = psize];
		Chain* p = &c;
		for (int i = 0; i < size; i++)
			chains[i] = p[i];
	};

	Greibach::Greibach(GRBALPHABET pstartN, GRBALPHABET pstbottom, short psize, Rule r, ...) // конструктор
	{
		startN = pstartN;
		stbottomT = pstbottom;
		rules = new Rule[size = psize];
		Rule* p = &r;
		for (int i = 0; i < size; i++)
			rules[i] = p[i];
	};

	Greibach getGreibach()
	{
		return greibach;
	};

	short Greibach::getRule(GRBALPHABET pnn, Rule& prule) // получить правило по нетерминалу, возвращающая номер правила или -1
	{
		short rc = -1;
		short k = 0;
		while (k < size && rules[k].nn != pnn)
			k++;
		if (k < size)
			prule = rules[rc = k];
		return rc;
	};

	Rule Greibach::getRule(short n)	// // получить правило по номеру
	{
		Rule rc;
		if (n < size)
			rc = rules[n];
		return rc;
	};

	char* Rule::Chain::getCChain(char* b)	// получить правую сторону правила (цепочку)
	{
		for (int i = 0; i < size; i++)
			b[i] = Chain::alphabet_to_char(nt[i]);
		b[size] = 0x00;
		return b;
	};
	char* Rule::getCRule(char* b, short nchain)		// полчить правило в виде N->цепочка
	{
		char bchain[200];
		b[0] = Chain::alphabet_to_char(nn);
		b[1] = '-'; b[2] = '>'; b[3] = 0x00;
		chains[nchain].getCChain(bchain);
		strcat_s(b, sizeof(bchain) + 5, bchain);
		return b;
	};

	short Rule::getNextChain(GRBALPHABET t, Rule::Chain& pchain, short j) // получить следующую за j подходящую цепочку, вернуть её номер или -1
	{
		short rc = -1;
		while (j < size && chains[j].nt[0] != t) // цикл по всем цепочкам в правиле
			++j;
		rc = (j < size ? j : -1);
		if (rc >= 0)
			pchain = chains[rc];
		return rc;
	};


}

file IN.cpp:
#include "pch.h"
namespace In
{

	IN getin(wchar_t infile[], std::ostream* stream)
	{

		unsigned char* text = new unsigned char[IN_MAX_LEN_TEXT];
		std::ifstream instream(infile);
		if (!instream.is_open())
			throw ERROR_THROW(102);
		IN in;
		int pos = 0;
		bool isLiteral = false;
		while (true)
		{
			unsigned char uch = instream.get();
			if (instream.eof())
				break;
			
			// Проверка границ перед записью
			if (in.size >= IN_MAX_LEN_TEXT - 1)
			{
				Log::WriteError(stream, Error::geterrorin(204, in.lines, pos));
				break; // Превышен максимальный размер файла
			}
			
			if (in.code[uch] == IN::Q)					// кавычка 
				isLiteral = !isLiteral;
			switch (in.code[uch])
			{
			case IN::N:									// новая строка 
				text[in.size++] = uch;
				in.lines++;
				pos = -1;
				break;
			case IN::L: // буквы
			case IN::D: // цифры
			case IN::H: // шестнадцатеричные цифры
			case IN::B: // двоичные цифры
			case IN::O: // операторы
			case IN::C: // сравнения
			case IN::S: // разделители
			case IN::Q: // кавычки
			case IN::A: // апостроф
			case IN::U: // подчеркивание
			case IN::W: // пробельные символы
			case IN::K: // логические литералы
				text[in.size++] = uch;
				break;
			case IN::I:// запрещённый символ
				Log::WriteError(stream, Error::geterrorin(200, in.lines, pos));
				in.ignor++;
				break;
			default:
				text[in.size++] = uch; // Записываем сам символ
			}
			pos++;
		}
		// Безопасная запись завершающего нуля
		if (in.size < IN_MAX_LEN_TEXT)
		text[in.size] = IN_CODE_NULL;
		else
			text[IN_MAX_LEN_TEXT - 1] = IN_CODE_NULL;
		in.text = text;
		instream.close(); // закрыть поток 
		return in;
	}
	void addWord(InWord* words, char* word, int line, int col)		// добавить слово в таблицу
	{
		if (word == nullptr || *word == IN_CODE_NULL || words->size >= IN_WORDS_MAXSIZE - 1)
			return;
		words[words->size].line = line;
		words[words->size].col = col;
		// Используем безопасное копирование с проверкой длины
		// Находим длину строки вручную, чтобы избежать проблем с отсутствующим '\0'
		size_t word_len = 0;
		for (size_t i = 0; i < MAX_LEN_BUFFER && word[i] != '\0'; i++)
		{
			word_len++;
		}
		// Ограничиваем длину до MAX_LEN_BUFFER - 1
		if (word_len >= MAX_LEN_BUFFER)
		{
			word_len = MAX_LEN_BUFFER - 1;
		}
		// Используем memcpy вместо strcpy_s для избежания проблем с буфером
		if (word_len > 0)
		{
			memcpy(words[words->size].word, word, word_len);
		}
		words[words->size].word[word_len] = '\0';
		words->size++;
	}

	InWord* getWordsTable(std::ostream* stream, unsigned char* text, int* code, int textSize)
	{
		InWord* words = new InWord[IN_WORDS_MAXSIZE];		//слова
		words->size = 0;
		int bufpos = 0;								// позиция в буфере
		int line = 1;								// номер строки исходного кода
		int col = 0;								// позиция в строке (колонка)
		int wordStartCol = 0;						// позиция начала текущего слова
		char buffer[MAX_LEN_BUFFER];				// буфер
		memset(buffer, 0, MAX_LEN_BUFFER);			// инициализация буфера нулями
		for (int i = 0; i < textSize; i++)			// заполнение
		{
			// Обновляем позицию колонки для каждого символа (кроме пробелов и переводов строки)
			if (code[text[i]] != IN::W && code[text[i]] != IN::N)
			{
				if (bufpos == 0)
				{
					// Начало нового слова - запоминаем позицию
					wordStartCol = col;
				}
				col++; // Увеличиваем позицию для каждого видимого символа
			}
			else if (code[text[i]] == IN::W)
			{
				col++; // Пробелы также учитываем в позиции
			}
			
			// Защита от переполнения буфера
			if (bufpos >= MAX_LEN_BUFFER - 1)
			{
				buffer[MAX_LEN_BUFFER - 1] = IN_CODE_NULL;
				addWord(words, buffer, line, wordStartCol);
				*buffer = IN_CODE_NULL;
				bufpos = 0;
			}
			
			switch (code[text[i]])
			{
			case IN::S:
			{
				// Проверяем, не является ли это оператором (операторы должны обрабатываться в case IN::O)
				if (code[text[i]] == IN::O)
				{
					// Это оператор, обрабатываем в case IN::O
					// Но если мы здесь, значит символ классифицирован и как S, и как O
					// Обрабатываем как разделитель
				}
				
				// Обработка символьных литералов ~A~, ~B~ и т.д.
				if (text[i] == IN_CODE_TILDA && i + 2 < textSize)
				{
					// Сохраняем текущий буфер, если он не пустой
					if (bufpos > 0 && buffer[0] != IN_CODE_NULL)
					{
						addWord(words, buffer, line, wordStartCol);
						memset(buffer, 0, MAX_LEN_BUFFER);
						bufpos = 0;
					}
					// Проверяем, является ли это символьным литералом ~A~
					if (i + 2 < textSize && text[i + 2] == IN_CODE_TILDA)
					{
						// Это символьный литерал ~A~
						if (bufpos < MAX_LEN_BUFFER - 3)
						{
							wordStartCol = col; // Запоминаем позицию начала литерала
							buffer[bufpos++] = text[i];     // ~
							buffer[bufpos++] = text[i + 1];  // A (или другой символ)
							buffer[bufpos++] = text[i + 2];  // ~
							buffer[bufpos] = IN_CODE_NULL;
							addWord(words, buffer, line, wordStartCol);
							memset(buffer, 0, MAX_LEN_BUFFER);
							bufpos = 0;
							i += 2; // Пропускаем все три символа
							break;
						}
					}
				}
				
				// Обработка минуса как унарного оператора или части литерала
				if ((i + 1 < textSize && text[i] == LEX_MINUS && isdigit(text[i + 1]))
					|| (words->size > 0 && text[i] == LEX_MINUS && words[words->size - 1].word[0] == '=')
					|| (i + 1 < textSize && text[i] == LEX_MINUS && text[i + 1] == LEX_MINUS && words->size > 0 && line > words[words->size - 1].line))
				{
					if (bufpos > 0 && buffer[0] != IN_CODE_NULL)
					{
						addWord(words, buffer, line, wordStartCol);
						memset(buffer, 0, MAX_LEN_BUFFER);
						bufpos = 0;
					}
					if (i + 1 < textSize && text[i + 1] == LEX_MINUS && words->size >= 2 && words[words->size - 1].line > words[words->size - 2].line)
					{
						wordStartCol = col; // Запоминаем позицию
						if (bufpos < MAX_LEN_BUFFER - 2)
					{
						buffer[bufpos++] = ':';
						buffer[bufpos++] = text[i];
						buffer[bufpos] = IN_CODE_NULL;
						}
						addWord(words, buffer, line, wordStartCol);
						memset(buffer, 0, MAX_LEN_BUFFER);
						bufpos = 0;
						i++;
						col++; // Учитываем второй символ
						break;
					}
					if ((words->size > 0 && isdigit(words[words->size - 1].word[strlen(words[words->size - 1].word) - 1]))
						|| (words->size > 0 && words[words->size - 1].word[0] == ')')
						|| (words->size > 0 && isalpha(words[words->size - 1].word[strlen(words[words->size - 1].word) - 1]))
						|| (i + 1 < textSize && isalpha(text[i + 1]))
						)
					{
						wordStartCol = col; // Запоминаем позицию
						if (bufpos < MAX_LEN_BUFFER - 1)
					{
						buffer[bufpos++] = text[i];
						buffer[bufpos] = IN_CODE_NULL;
						}
						addWord(words, buffer, line, wordStartCol);
						memset(buffer, 0, MAX_LEN_BUFFER);
						bufpos = 0;
						break;
					}
					wordStartCol = col; // Запоминаем позицию
					if (bufpos < MAX_LEN_BUFFER - 1)
					{
					buffer[bufpos++] = text[i];
					buffer[bufpos] = IN_CODE_NULL;
					}
					break;
				}
				// Обработка инкремента/декремента (++, --, **, //)
				if ((i + 1 < textSize && text[i] == LEX_PLUS && text[i + 1] == LEX_PLUS)
					|| (i + 1 < textSize && text[i] == LEX_STAR && text[i + 1] == LEX_STAR)
					|| (i + 1 < textSize && text[i] == LEX_DIRSLASH && text[i + 1] == LEX_DIRSLASH))
				{
					if (bufpos > 0 && buffer[0] != IN_CODE_NULL)
					{
						addWord(words, buffer, line, wordStartCol);
						memset(buffer, 0, MAX_LEN_BUFFER);
						bufpos = 0;
					}
					wordStartCol = col; // Запоминаем позицию
					if (bufpos < MAX_LEN_BUFFER - 2)
					{
					buffer[bufpos++] = ':';
					buffer[bufpos++] = text[i];
					buffer[bufpos] = IN_CODE_NULL;
					}
					addWord(words, buffer, line, wordStartCol);
					memset(buffer, 0, MAX_LEN_BUFFER);
					bufpos = 0;
					i++;
					col++; // Учитываем второй символ
					break;
				}
				// Обычные разделители (;, ,, :, (, ), {, }, [, ])
				// Сохраняем буфер, если он не пустой (это может быть число или идентификатор перед разделителем)
				if (bufpos > 0 && buffer[0] != IN_CODE_NULL)
				{
					addWord(words, buffer, line, wordStartCol);
					memset(buffer, 0, MAX_LEN_BUFFER);
				bufpos = 0;
				}
				char letter[2] = { (char)text[i], IN_CODE_NULL };
				addWord(words, letter, line, col);
				break;
			}
			case IN::K:
			{
				while (i < textSize && text[i] != '\n')
				{
					i++;
				}
				if (bufpos > 0 && buffer[0] != IN_CODE_NULL)
				{
					addWord(words, buffer, line, wordStartCol);
					memset(buffer, 0, MAX_LEN_BUFFER);
					bufpos = 0;
				}
				line++;
				col = 0; // Сбрасываем позицию при переводе строки
				break;
			}
			case IN::N:											//новая строка
			case IN::W:											// пробельные символы
				// Сохраняем буфер, если он не пустой (это может быть число или идентификатор)
				if (bufpos > 0 && buffer[0] != IN_CODE_NULL)
				{
					addWord(words, buffer, line, wordStartCol);
					memset(buffer, 0, MAX_LEN_BUFFER);
					bufpos = 0;
				}
				if (code[text[i]] == IN::N)
				{
					line++;
					col = 0; // Сбрасываем позицию при переводе строки
				}
				break;
			case IN::A: // Апостроф (символьный литерал) - обрабатываем как начало литерала
			{
				if (bufpos > 0 && buffer[0] != IN_CODE_NULL)
			{
				addWord(words, buffer, line, wordStartCol);
					memset(buffer, 0, MAX_LEN_BUFFER);
				bufpos = 0;
				}
				// Обрабатываем символьный литерал (например, '0x1A', 'A', '0b1010' и т.д.)
				if (bufpos < MAX_LEN_BUFFER - 1)
				{
					wordStartCol = col; // Запоминаем позицию начала литерала
					buffer[bufpos++] = IN_CODE_APOST;
					for (int j = 1; ; j++)
				{
						if (j == 256 || i + j >= textSize || bufpos >= MAX_LEN_BUFFER - 1)
				{
					Log::WriteError(stream, Error::geterrorin(312, line, wordStartCol));
					break;
				}
						buffer[bufpos++] = text[i + j];
						col++; // Учитываем символ внутри литерала
						if (text[i + j] == IN_CODE_APOST) // Закрывающая кавычка
						{
				buffer[bufpos] = IN_CODE_NULL;
				addWord(words, buffer, line, wordStartCol);
							i = i + j;
							memset(buffer, 0, MAX_LEN_BUFFER);
							bufpos = 0;
							break;
						}
						if (code[text[i + j]] == IN::N)
						{
							Log::WriteError(stream, Error::geterrorin(311, line, 0));
							break;
						}
					}
				}
				memset(buffer, 0, MAX_LEN_BUFFER);
				bufpos = 0;
				break;
			}
			case IN::Q:		// строковый литерал
			{
				if (bufpos > 0 && buffer[0] != IN_CODE_NULL)
			{
				addWord(words, buffer, line, wordStartCol);
					memset(buffer, 0, MAX_LEN_BUFFER);
				bufpos = 0;
				}
				bool isltrlgood = true;
				// если литерал не закрыт - перевод строки будет раньше кавычки
				int stringStartCol = col; // Запоминаем позицию начала строкового литерала
				for (int j = i + 1; j < textSize && text[j] != IN_CODE_QUOTE; j++)
				{
					if (code[text[j]] == IN::N)
					{
						Log::WriteError(stream, Error::geterrorin(311, line, stringStartCol));
						isltrlgood = false; // литерал не закрыт!
						break;
					}
				}
				if (isltrlgood && bufpos < MAX_LEN_BUFFER - 1)
				{
					wordStartCol = col; // Запоминаем позицию начала строкового литерала
					buffer[bufpos++] = IN_CODE_QUOTE;
					int string_length = 0; // Счетчик длины строки без кавычек
					bool error_312_reported = false; // Флаг, чтобы не выводить ошибку 312 дважды
					for (int j = 1; ; j++)
					{
						// Проверяем размер строкового литерала (без учета кавычек)
						// STR_MAXSIZE - максимальная длина строки без кавычек
						// string_length - количество символов, которые мы уже прочитали
						
						if (i + j >= textSize)
						{
							// Достигнут конец файла
							if (string_length >= STR_MAXSIZE && !error_312_reported)
							{
								Log::WriteError(stream, Error::geterrorin(312, line, wordStartCol));
								error_312_reported = true;
							}
							break;
						}
						
						if (text[i + j] == IN_CODE_QUOTE) // закрывающая кавычка
						{
							// Проверяем размер строки перед добавлением в таблицу слов
							if (string_length >= STR_MAXSIZE && !error_312_reported)
							{
								Log::WriteError(stream, Error::geterrorin(312, line, wordStartCol));
								error_312_reported = true;
							}
							// Убеждаемся, что буфер заканчивается '\0'
							// Ограничиваем bufpos до MAX_LEN_BUFFER - 1, чтобы оставить место для '\0'
							// Также ограничиваем до STR_MAXSIZE + 1 (открывающая кавычка + STR_MAXSIZE символов)
							size_t max_buf_pos = (STR_MAXSIZE + 1 < MAX_LEN_BUFFER - 1) ? (STR_MAXSIZE + 1) : (MAX_LEN_BUFFER - 1);
							if ((size_t)bufpos >= max_buf_pos)
							{
								bufpos = max_buf_pos - 1; // Оставляем место для закрывающей кавычки и '\0'
							}
							if (bufpos < MAX_LEN_BUFFER - 1)
							{
								buffer[bufpos++] = IN_CODE_QUOTE; // Добавляем закрывающую кавычку
							}
							buffer[bufpos] = IN_CODE_NULL; // Гарантируем завершение строки
							addWord(words, buffer, line, wordStartCol);
							i = i + j;
							col += j + 1; // Учитываем все символы строкового литерала
							break;
						}
						
						// Увеличиваем счетчик длины строки ПЕРЕД проверкой
						string_length++;
						
						// Проверяем размер после увеличения счетчика (независимо от переполнения буфера)
						// Это должно быть ПЕРВОЙ проверкой, чтобы ошибка 312 выводилась сразу
						if (string_length > STR_MAXSIZE && !error_312_reported)
						{
							// Превышен размер строкового литерала
							Log::WriteError(stream, Error::geterrorin(312, line, wordStartCol));
							error_312_reported = true;
							// НЕ прерываем цикл, продолжаем искать закрывающую кавычку
							// чтобы строка обрабатывалась как строковый литерал
						}
						
						// Копируем символ только если не превышен размер буфера И не превышен лимит STR_MAXSIZE
						// Это предотвращает ошибку "Buffer is too small" при копировании в vstr.str
						if (bufpos < MAX_LEN_BUFFER - 1 && string_length <= STR_MAXSIZE)
						{
							// Копируем только если не превышен лимит STR_MAXSIZE
							buffer[bufpos++] = text[i + j];
						}
						// Если превышен лимит STR_MAXSIZE, не копируем в buffer, но продолжаем искать закрывающую кавычку
						// Это позволяет строке обрабатываться как строковый литерал (не будет ошибки 201)
					}
				} // literal good
				memset(buffer, 0, MAX_LEN_BUFFER);
				bufpos = 0;
				break;
			}
			case IN::O: // Операторы (+ - * / %)
			{
				// Сохраняем текущий буфер, если он не пустой (это может быть число перед оператором)
				if (bufpos > 0 && buffer[0] != IN_CODE_NULL)
				{
					addWord(words, buffer, line, wordStartCol);
					memset(buffer, 0, MAX_LEN_BUFFER);
					bufpos = 0;
				}
				// Добавляем оператор как отдельное слово
				char op[2] = { (char)text[i], IN_CODE_NULL };
				addWord(words, op, line, col);
				break;
			}
			case IN::L: // Буквы (A-Z, a-z) - добавляем в буфер для формирования идентификаторов и ключевых слов
			{
				// Добавляем букву в буфер
				if (bufpos < MAX_LEN_BUFFER - 1)
				{
					buffer[bufpos++] = text[i];
					buffer[bufpos] = IN_CODE_NULL;
				}
				break;
			}
			case IN::D: // Цифры (0-9) - добавляем в буфер для формирования чисел
			case IN::H: // Шестнадцатеричные цифры (A-F, a-f)
			case IN::B: // Двоичные цифры (0, 1)
			{
				// Добавляем цифру в буфер
				if (bufpos < MAX_LEN_BUFFER - 1)
				{
					buffer[bufpos++] = text[i];
					buffer[bufpos] = IN_CODE_NULL;
				}
				break;
			}
			default:
				// Обрабатываем обратные кавычки как допустимые символы (особенно внутри строковых литералов)
				if (code[text[i]] == IN::L && text[i] == '`')
				{
					// Обратная кавычка - допустимый символ, особенно внутри строк
					if (bufpos < MAX_LEN_BUFFER - 1)
					{
						buffer[bufpos++] = text[i];
						buffer[bufpos] = IN_CODE_NULL;
					}
				}
				else if (bufpos < MAX_LEN_BUFFER - 1)
				{
				buffer[bufpos++] = text[i];
				buffer[bufpos] = IN_CODE_NULL;
			}
		}
		}
		
		// Добавляем последнее слово из буфера, если оно есть
		if (bufpos > 0 && buffer[0] != IN_CODE_NULL)
		{
			addWord(words, buffer, line, wordStartCol);
		}
		
		return words;
	}
	void printTable(InWord* table)								// вывод таблицы на экран
	{
		std::cout << " ------------------ ТАБЛИЦА СЛОВ: ------------------" << std::endl;
		for (int i = 0; i < table->size; i++)
			std::cout << std::setw(5) << i << std::setw(5) << table[i].line << " |  " << table[i].word << std::endl;
	}

}

file IT.cpp:
#include "pch.h"
#define W(x, y)\
		<< std::setw(x) << (y) <<
#define STR(n, line, type, id)\
		"|" W(4,n) " |  " W(6,line) "    |" W(21,type) " |  " W(SCOPED_ID_MAXSIZE, id) " |"
namespace IT
{
	IdTable Create(int size)
	{
		if (size > MAXSIZE_TI)
		{
			Error::ERROR err = Error::geterror(203);
			throw err;
		}
		IdTable idtable;
		idtable.table = new Entry[idtable.maxsize = size];
		idtable.size = 0;
		return idtable;
	}
	void Add(IdTable& idtable, Entry entry)
	{
		if (static_cast<unsigned int>(idtable.size) >= static_cast<unsigned int>(idtable.maxsize))
		{
			Error::ERROR err = Error::geterror(203);
			throw err;
		}
		idtable.table[idtable.size++] = entry;
	}

	// возврат: номер строки(если есть), TI_NULLIDX(если нет)
	int isId(IdTable& idtable, const char id[SCOPED_ID_MAXSIZE])
	{
		for (int i = 0; i < idtable.size; i++)
		{
			if (strcmp(idtable.table[i].id, id) == 0)
				return i;
		}
		return TI_NULLIDX;
	}

	bool SetValue(IT::IdTable& idtable, int index, const char* value)
	{
		return SetValue(&(idtable.table[index]), value);
	}
	bool SetValue(IT::Entry* entry, const char* value) // установка значения переменной
	{
		bool rc = true;
		if (entry->iddatatype == INT)
		{
			short temp = 0;
			const char* parseValue = value;
			bool hasQuotes = (value[0] == IN_CODE_APOST && value[strlen(value) - 1] == IN_CODE_APOST);
			
			// Если значение в кавычках, убираем их
			if (hasQuotes && strlen(value) > 2)
			{
				size_t bufSize = strlen(value) - 1; // Размер без кавычек + 1 для '\0'
				char* tempBuf = new char[bufSize];
				strncpy_s(tempBuf, bufSize, value + 1, strlen(value) - 2);
				tempBuf[strlen(value) - 2] = '\0';
				parseValue = tempBuf;
			}
			
			bool valueValid = true; // Флаг валидности значения
			long long temp_long = 0; // Используем long long для проверки диапазона
			
			if ((parseValue[0] == '-' && (parseValue[1] == '0' && (parseValue[2] == 'x' || parseValue[2] == 'X'))) || (parseValue[0] == '0' && (parseValue[1] == 'x' || parseValue[1] == 'X')))
			{
				// Шестнадцатеричный литерал
				char* endptr;
				temp_long = strtoll(parseValue, &endptr, 16);
				// Проверяем, что значение входит в диапазон short
				if (temp_long > TI_INT_MAXSIZE || temp_long < TI_INT_MINSIZE)
				{
					valueValid = false;
				}
				temp = (short)temp_long;
			}
			else if ((parseValue[0] == '-' && parseValue[1] == '0' && (parseValue[2] == 'b' || parseValue[2] == 'B')) || (parseValue[0] == '0' && (parseValue[1] == 'b' || parseValue[1] == 'B')))
			{
				// Двоичный литерал
				const char* binStr = parseValue;
				if (parseValue[0] == '-')
					binStr = parseValue + 3; // пропускаем "-0b"
				else
					binStr = parseValue + 2; // пропускаем "0b"
				temp_long = 0;
				for (int i = 0; binStr[i] != '\0'; i++)
				{
					if (binStr[i] == '0' || binStr[i] == '1')
						temp_long = (temp_long << 1) | (binStr[i] - '0');
				}
				if (parseValue[0] == '-')
					temp_long = -temp_long;
				// Проверяем, что значение входит в диапазон short
				if (temp_long > TI_INT_MAXSIZE || temp_long < TI_INT_MINSIZE)
				{
					valueValid = false;
				}
				temp = (short)temp_long;
			}
			else if ((parseValue[0] == '-' && parseValue[1] == '0') || parseValue[0] == '0')
			{
				// Восьмеричный литерал
				char* endptr;
				temp_long = strtoll(parseValue, &endptr, 8);
				// Проверяем, что значение входит в диапазон short
				if (temp_long > TI_INT_MAXSIZE || temp_long < TI_INT_MINSIZE)
				{
					valueValid = false;
				}
				temp = (short)temp_long;
			}
			else if (isalpha(parseValue[0]))
			{
				// Логический литерал произвольного представления
				char lower[256];
				for (int i = 0; parseValue[i] != '\0' && i < 255; i++)
					lower[i] = tolower(parseValue[i]);
				lower[255] = '\0';
				if (strstr(lower, "true") || strstr(lower, "истина") || strstr(lower, "да") ||
					strstr(lower, "yes") || strstr(lower, "1") || strstr(lower, "+") ||
					strstr(lower, "on") || strstr(lower, "вкл"))
					temp = 1;
				else if (strstr(lower, "false") || strstr(lower, "ложь") || strstr(lower, "нет") ||
					strstr(lower, "no") || strstr(lower, "0") || strstr(lower, "-") ||
					strstr(lower, "off") || strstr(lower, "выкл"))
					temp = 0;
				else
				{
					// Попытка преобразовать как число
					char* endptr;
					temp_long = strtoll(parseValue, &endptr, 10);
					// Проверяем, что значение входит в диапазон short
					if (temp_long > TI_INT_MAXSIZE || temp_long < TI_INT_MINSIZE)
					{
						valueValid = false;
					}
					temp = (short)temp_long;
				}
			}
			else
			{
				// Десятичный литерал
				char* endptr;
				temp_long = strtoll(parseValue, &endptr, 10);
				// Проверяем, что значение входит в диапазон short
				if (temp_long > TI_INT_MAXSIZE || temp_long < TI_INT_MINSIZE)
				{
					valueValid = false;
				}
				temp = (short)temp_long;
			}
			
			// Освобождаем временный буфер если использовали
			if (hasQuotes && strlen(value) > 2)
			{
				delete[] const_cast<char*>(parseValue);
			}
			
			// Если значение невалидно, устанавливаем rc = false
			if (!valueValid)
			{
				rc = false;
				// Обрезаем значение до допустимого диапазона
				if (temp_long > TI_INT_MAXSIZE)
					temp = TI_INT_MAXSIZE;
				else if (temp_long < TI_INT_MINSIZE)
					temp = TI_INT_MINSIZE;
			}
			
			entry->value.vint = temp;
		}
		else if (entry->iddatatype == STR)
		{
			size_t value_len = strlen(value);
			// Вычисляем длину строки без кавычек
			size_t str_len = (value_len >= 2) ? (value_len - 2) : 0;
			
			// Проверяем размер перед копированием, чтобы избежать переполнения буфера
			// entry->value.vstr.str имеет размер STR_MAXSIZE - 1
			// Нужно оставить место для '\0', поэтому максимальная длина = STR_MAXSIZE - 2
			size_t max_str_size = STR_MAXSIZE - 1; // Размер буфера
			size_t max_copy_len = max_str_size - 1; // Максимальная длина для копирования (с учетом '\0')
			
			// Проверяем, не превышает ли строка максимальный размер
			// Если превышает, обрезаем до максимального размера
			// Ошибка 312 уже должна быть выведена в In.cpp при чтении строки
			if (str_len > max_copy_len)
			{
				// Строка слишком длинная, обрезаем до максимального размера
				str_len = max_copy_len;
			}
			
			if (value_len >= 2)
			{
				// Копируем строку без кавычек, используя безопасное копирование
				// Размер буфера = STR_MAXSIZE - 1, копируем максимум STR_MAXSIZE - 2 символов
				// Используем memcpy для избежания проблем с strncpy_s
				if (str_len > 0)
				{
					memcpy(entry->value.vstr.str, value + 1, str_len);
				}
				entry->value.vstr.str[str_len] = '\0';
				entry->value.vstr.len = static_cast<int>(str_len);
			}
			else
			{
				entry->value.vstr.str[0] = '\0';
				entry->value.vstr.len = 0;
			}
		}
		else
		{
			entry->value.symbol = value[1];
		}
		return rc;
	}
	void writeIdTable(std::ostream* stream, IT::IdTable& idtable)
	{
		*stream << "---------------------------- ТАБЛИЦА ИДЕНТИФИКАТОРОВ ------------------------\n" << std::endl;
		*stream << "|  N  |СТРОКА В ТЛ |  ТИП ИДЕНТИФИКАТОРА  |        ИМЯ         | ЗНАЧЕНИЕ (ПАРАМЕТРЫ)" << std::endl;
		for (int i = 0; i < idtable.size; i++)
		{
			IT::Entry* e = &idtable.table[i];
			char type[50] = "";

			switch (e->iddatatype)
			{
			case IT::IDDATATYPE::INT:
				strcat_s(type, 50, "  integer ");
				break;
			case IT::IDDATATYPE::STR:
				strcat_s(type, 50, " string  ");
				break;
			case IT::IDDATATYPE::SYM:
				strcat_s(type, 50, "   sumbol  ");
				break;
			case IT::IDDATATYPE::UNDEF:
				strcat_s(type, 50, "UNDEFINED");
				break;
			}
			switch (e->idtype)
			{
			case IT::IDTYPE::V:
				strcat_s(type, 50, "  variable");
				break;
			case IT::IDTYPE::F:
				strcat_s(type, 50, "  function");
				break;
			case IT::IDTYPE::P:
				strcat_s(type, 50, " parameter");
				break;
			case IT::IDTYPE::L:
				strcat_s(type, 50, "   literal");
				break;
			case IT::IDTYPE::S:
				strcat_s(type, 50, "  LIB FUNC");
				break;
			default:
				strcat_s(type, 50, "UNDEFINED ");
				break;
			}

			*stream << STR(i, e->idxfirstLE, type, e->id);
			if ((e->idtype == IT::IDTYPE::L || e->idtype == IT::IDTYPE::V) && e->iddatatype != IT::IDDATATYPE::UNDEF)
			{
				if (e->iddatatype == IT::IDDATATYPE::INT)
					*stream << e->value.vint;
				else if (e->iddatatype == IT::IDDATATYPE::STR)
					*stream << "[" << (int)e->value.vstr.len << "]" << e->value.vstr.str;
				else
					*stream << e->value.symbol;
			}
			if (e->idtype == IT::IDTYPE::F || e->idtype == IT::IDTYPE::S)
			{
				for (int i = 0; i < e->value.params.count; i++)
				{
					*stream << " P" << i << ":";
					switch (e->value.params.types[i])
					{
					case IT::IDDATATYPE::INT:
						*stream << "INTEGER |";
						break;
					case IT::IDDATATYPE::STR:
						*stream << "STRING |";
						break;
					case IT::IDDATATYPE::SYM:
						*stream << "SYMBOL |";
						break;
					case IT::IDDATATYPE::UNDEF:
						*stream << "UNDEFINED";
						break;
					}
				}
			}
			*stream << std::endl;
		}
		*stream << "\n-------------------------------------------------------------------------\n\n";
	}


};

file LezAnaliz.cpp:
#pragma once
#include "pch.h"
namespace Lex
{
	Graph graphs[N_GRAPHS] =
	{
		{ LEX_SEPARATORS, FST::FST(GRAPH_SEPARATORS) },
		{ LEX_SEPARATORS, FST::FST(GRAPH_INKR) },
		{ LEX_ID_TYPE, FST::FST(GRAPH_INTEGER) },
		{ LEX_VOID, FST::FST(GRAPH_VOID) },
		{ LEX_STDFUNC, FST::FST(GRAPH_POW) },
		{ LEX_STDFUNC, FST::FST(GRAPH_RANDOM) },
		{ LEX_STDFUNC, FST::FST(GRAPH_LENGTH) },
		{ LEX_STDFUNC, FST::FST(GRAPH_COMPARE) },
		{ LEX_LITERAL, FST::FST(GRAPH_HEX_BIN_LITERAL) },
		{ LEX_LITERAL, FST::FST(GRAPH_INT_LITERAL) },
		{ LEX_LITERAL, FST::FST(GRAPH_STRING_LITERAL) },
		{ LEX_LITERAL, FST::FST(GRAPH_SYMBOL_LITERAL) },
		{ LEX_LITERAL, FST::FST(GRAPH_INT_NEGATIVE) },
		{ LEX_ISTRUE, FST::FST(GRAPH_ISTRUE) }, // Проверяем "true" как ключевое слово перед идентификаторами
		{ LEX_ISFALSE, FST::FST(GRAPH_ISFALSE) }, // Проверяем "false" как ключевое слово перед идентификаторами
		{ LEX_TYPE, FST::FST(GRAPH_TYPE) },
		{ LEX_MAIN, FST::FST(GRAPH_MAIN) },
		{ LEX_ID_TYPE, FST::FST(GRAPH_STRING) },
		{ LEX_FUNCTION, FST::FST(GRAPH_FUNCTION) },
		{ LEX_ID_TYPE, FST::FST(GRAPH_SYMBOL) },
		{ LEX_RETURN, FST::FST(GRAPH_RETURN) },
		{ LEX_WRITE, FST::FST(GRAPH_WRITE) },
		{ LEX_NEWLINE, FST::FST(GRAPH_WRITELINE) },
		{ LEX_IS, FST::FST(GRAPH_IS) },
		{ LEX_WHILE, FST::FST(GRAPH_WHILE) },
		{ LEX_REPEAT, FST::FST(GRAPH_REPEAT) },
		{ LEX_TIMES, FST::FST(GRAPH_TIMES) },
		{ LEX_DO, FST::FST(GRAPH_DO) },
		{ LEX_LITERAL, FST::FST(GRAPH_BOOL_LITERAL) }, // Булевые литералы проверяются ПОСЛЕ ключевых слов
		{ LEX_ID, FST::FST(GRAPH_ID) } // Идентификаторы проверяются в последнюю очередь
	};

	const char* getScopeName(IT::IdTable idtable, const char* prevword)
	{
		// Проверка на валидность указателя
		if (prevword == nullptr || *prevword == '\0')
			return nullptr;
		
		if (strcmp(prevword, MAIN) == 0)
			return "main";
		for (int i = idtable.size - 1; i >= 0; i--)
			if (idtable.table[i].idtype == IT::IDTYPE::F || idtable.table[i].idtype == IT::IDTYPE::S)
				return idtable.table[i].id;
		return nullptr;
	}

	bool isLiteral(const char* id)
	{
		if (isdigit(static_cast<unsigned char>(*id)) || *id == IN_CODE_QUOTE || *id == LEX_MINUS || *id == IN_CODE_TILDA || *id == '\0' || *id == IN_CODE_APOST)
			return true;
		return false;
	}

	short parseBoolLiteral(const char* value)
	{
		char lower[256] = { 0 };
		for (int i = 0; value[i] != '\0' && i < 255; i++)
			lower[i] = tolower(static_cast<unsigned char>(value[i]));

		if (strstr(lower, "true") || strstr(lower, "истина") || strstr(lower, "да") ||
			strstr(lower, "yes") || strstr(lower, "1") || strstr(lower, "+") ||
			strstr(lower, "on") || strstr(lower, "вкл"))
			return 1;
		if (strstr(lower, "false") || strstr(lower, "ложь") || strstr(lower, "нет") ||
			strstr(lower, "no") || strstr(lower, "0") || strstr(lower, "-") ||
			strstr(lower, "off") || strstr(lower, "выкл"))
			return 0;
		return 0;
	}

	IT::STDFNC getStandFunction(const char* id)
	{
		if (!strcmp(RANDOM, id))
			return IT::STDFNC::F_RANDOM;
		if (!strcmp(POW, id))
			return IT::STDFNC::F_POW;
		if (!strcmp(LENGHT, id))
			return IT::STDFNC::F_LENGTH;
		if (!strcmp(COMPARE, id))
			return IT::STDFNC::F_COMPARE;
		return IT::STDFNC::F_NOT_STD;
	}

	int getLiteralIndex(IT::IdTable ittable, const char* value, IT::IDDATATYPE type)
	{
		for (int i = 0; i < ittable.size; i++)
		{
			if (ittable.table[i].idtype == IT::IDTYPE::L && ittable.table[i].iddatatype == type)
			{
				switch (type)
				{
				case IT::IDDATATYPE::INT:
				{
					short temp;
					const char* parseValue = value;
					char* tempBuf = nullptr;
					bool hasQuotes = (value[0] == IN_CODE_APOST && value[strlen(value) - 1] == IN_CODE_APOST);
					
					// Если значение в кавычках, убираем их
					if (hasQuotes && strlen(value) > 2)
					{
						size_t bufSize = strlen(value) - 1; // Размер без кавычек + 1 для '\0'
						tempBuf = new char[bufSize];
						strncpy_s(tempBuf, bufSize, value + 1, strlen(value) - 2);
						tempBuf[strlen(value) - 2] = '\0';
						parseValue = tempBuf;
					}
					
					// Правильная обработка шестнадцатеричных и других форматов
					if ((parseValue[0] == '-' && (parseValue[1] == '0' && (parseValue[2] == 'x' || parseValue[2] == 'X'))) || (parseValue[0] == '0' && (parseValue[1] == 'x' || parseValue[1] == 'X')))
						temp = (short)strtol(parseValue, NULL, 16);
					else if ((parseValue[0] == '-' && parseValue[1] == '0' && (parseValue[2] == 'b' || parseValue[2] == 'B')) || (parseValue[0] == '0' && (parseValue[1] == 'b' || parseValue[1] == 'B')))
					{
						// Бинарный формат
						const char* binStr = parseValue;
						if (parseValue[0] == '-')
							binStr = parseValue + 3;
						else
							binStr = parseValue + 2;
						temp = 0;
						for (int j = 0; binStr[j] != '\0'; j++)
						{
							if (binStr[j] == '0' || binStr[j] == '1')
								temp = (temp << 1) | (binStr[j] - '0');
						}
						if (parseValue[0] == '-')
							temp = -temp;
				}
				else if ((parseValue[0] == '-' && parseValue[1] == '0') || parseValue[0] == '0')
					temp = (short)strtol(parseValue, NULL, 8);
				else if (isalpha(parseValue[0]))
				{
					// Логический литерал произвольного представления
					char lower[256] = { 0 };
					for (int j = 0; parseValue[j] != '\0' && j < 255; j++)
						lower[j] = tolower(parseValue[j]);
					lower[255] = '\0';
					if (strstr(lower, "true") || strstr(lower, "истина") || strstr(lower, "да") ||
						strstr(lower, "yes") || strstr(lower, "1") || strstr(lower, "+") ||
						strstr(lower, "on") || strstr(lower, "вкл"))
						temp = 1;
					else if (strstr(lower, "false") || strstr(lower, "ложь") || strstr(lower, "нет") ||
						strstr(lower, "no") || strstr(lower, "0") || strstr(lower, "-") ||
						strstr(lower, "off") || strstr(lower, "выкл"))
						temp = 0;
					else
						temp = (short)atoi(parseValue); // попытка преобразовать как число
				}
				else
					temp = (short)atoi(parseValue);
				
				// Освобождаем временный буфер если использовали
				if (tempBuf != nullptr)
				{
					delete[] tempBuf;
				}
				
				if (ittable.table[i].value.vint == temp)
						return i;
					break;
				}
				case IT::IDDATATYPE::STR:
				{
					if (strlen(value) < 2) break;
					char buf[STR_MAXSIZE] = { 0 };
					size_t copy_len = strlen(value) - 2;
					// Ограничиваем длину до STR_MAXSIZE - 1, чтобы избежать переполнения
					if (copy_len >= STR_MAXSIZE)
						copy_len = STR_MAXSIZE - 1;
					// Используем memcpy вместо strncpy_s для избежания проблем с размером буфера
					if (copy_len > 0)
					{
						memcpy(buf, value + 1, copy_len);
					}
					buf[copy_len] = '\0';
					if (strcmp((char*)ittable.table[i].value.vstr.str, buf) == 0)
						return i;
					break;
				}
				case IT::IDDATATYPE::SYM:
					if (ittable.table[i].value.symbol == value[1])
						return i;
					break;
				}
			}
		}
		return TI_NULLIDX;
	}

	IT::IDDATATYPE getType(const char* curword, const char* idtype)
	{
		if (idtype == nullptr)
			return IT::IDDATATYPE::UNDEF;
		if (!strcmp(TYPE_SYMBOL, idtype))
			return IT::IDDATATYPE::SYM;
		if (!strcmp(TYPE_VOID, idtype))
			return IT::IDDATATYPE::PROC;
		if (!strcmp(TYPE_STRING, idtype))
			return IT::IDDATATYPE::STR;
		if (!strcmp(TYPE_INTEGER, idtype))
			return IT::IDDATATYPE::INT;
		if (curword && (isdigit(static_cast<unsigned char>(*curword)) || *curword == LEX_MINUS || *curword == IN_CODE_APOST || (*curword == '0' && (curword[1] == 'x' || curword[1] == 'b')) || 
			(*curword == IN_CODE_APOST && curword[1] == '0' && (curword[2] == 'x' || curword[2] == 'X' || curword[2] == 'b' || curword[2] == 'B')) ||
			(*curword == IN_CODE_APOST && curword[1] == '-' && curword[2] == '0' && (curword[3] == 'x' || curword[3] == 'X' || curword[3] == 'b' || curword[3] == 'B'))))
			return IT::IDDATATYPE::INT;
		else if (curword && *curword == IN_CODE_QUOTE)
			return IT::IDDATATYPE::STR;
		else if (curword && *curword == IN_CODE_TILDA)
			return IT::IDDATATYPE::SYM;
		else if (curword && isalpha(static_cast<unsigned char>(*curword)))
		{
			char lower[256] = { 0 };
			for (int i = 0; curword[i] != '\0' && i < 255; i++)
				lower[i] = tolower(static_cast<unsigned char>(curword[i]));

			if (strstr(lower, "true") || strstr(lower, "false") || strstr(lower, "истина") ||
				strstr(lower, "ложь") || strstr(lower, "да") || strstr(lower, "нет") ||
				strstr(lower, "yes") || strstr(lower, "no") || strstr(lower, "on") ||
				strstr(lower, "off") || strstr(lower, "вкл") || strstr(lower, "выкл"))
				return IT::IDDATATYPE::INT;
		}

		return IT::IDDATATYPE::UNDEF;
	}

	char* getNextLiteralName()
	{
		static int literalNumber = 1;
		char* buf = new char[SCOPED_ID_MAXSIZE];
		snprintf(buf, SCOPED_ID_MAXSIZE, "L%d", literalNumber++);
		return buf;
	}

	int getIndexInLT(LT::LexTable& lextable, int itTableIndex)
	{
		if (itTableIndex == TI_NULLIDX)
			return lextable.size;
		for (int i = 0; i < lextable.size; i++)
			if (itTableIndex == lextable.table[i].idxTI)
				return i;
		return TI_NULLIDX;
	}

	// Проверка, является ли слово ключевым (case-insensitive)
	bool isKeyword(const char* word)
	{
		char lower[256] = { 0 };
		for (int i = 0; word[i] != '\0' && i < 255; i++)
			lower[i] = tolower(static_cast<unsigned char>(word[i]));
		
		const char* keywords[] = { "type", "integer", "string", "symbol", "function", "main", "return", 
			"write", "writeline", "is", "while", "repeat", "times", "do", "pow", "random", "lenght", "compare", "void" };
		for (int i = 0; i < sizeof(keywords) / sizeof(keywords[0]); i++)
		{
			if (strcmp(lower, keywords[i]) == 0)
				return true;
		}
		return false;
	}

	IT::Entry* getEntry(
		Lex::LEX& tables,
		char lex,
		const char* id,
		const char* idtype,
		bool isParam,
		bool isFunc,
		Log::LOG log,
		int line,
		int col,
		bool& lex_ok,
		const char* originalWord = nullptr)
	{
		IT::IDDATATYPE type = getType(id, idtype);
		int index = IT::isId(tables.idtable, id);
		if (lex == LEX_LITERAL)
			index = getLiteralIndex(tables.idtable, id, type);
		if (index != TI_NULLIDX)
			return nullptr;

		std::unique_ptr<IT::Entry> itentry = std::make_unique<IT::Entry>();
		itentry->iddatatype = type;
		itentry->idxfirstLE = getIndexInLT(tables.lextable, index);

		// Проверка, что имя переменной не является ключевым словом (только для переменных)
		// Проверяем как LEX_ID, так и LEX_ID_TYPE (когда используется как имя переменной, а не как тип данных)
		if ((lex == LEX_ID || lex == LEX_ID_TYPE) && !isFunc)
		{
			// Используем исходное слово для проверки (без префикса области видимости)
			// Если originalWord не передан, извлекаем из id
			const char* nameToCheck = originalWord;
			if (nameToCheck == nullptr)
			{
				// Получаем чистое имя переменной без префикса области видимости
				const char* varName = strrchr(id, '_');
				nameToCheck = (varName != nullptr) ? varName + 1 : id;
			}
			
			// Для LEX_ID_TYPE нужно проверить контекст: если перед ним стоит LEX_TYPE, то это тип данных, иначе - имя переменной
			if (lex == LEX_ID_TYPE)
			{
				// Проверяем, не является ли это типом данных (type integer x = ...)
				// Если в таблице лексем перед текущей позицией есть LEX_TYPE, то это тип данных, пропускаем проверку
				// Если перед LEX_ID_TYPE стоит другой LEX_ID_TYPE (например, type integer INTEGER), то это имя переменной
				bool isTypeDeclaration = false;
				if (tables.lextable.size > 0)
				{
					int lastIdx = tables.lextable.size - 1;
					// Если предыдущая лексема - это LEX_TYPE, то текущая LEX_ID_TYPE - это тип данных (integer, string, symbol)
					if (lastIdx >= 0 && tables.lextable.table[lastIdx].lexema == LEX_TYPE)
					{
						// Это тип данных (type integer), не проверяем как ключевое слово
						isTypeDeclaration = true;
					}
					// Если предыдущая лексема - это LEX_ID_TYPE, то текущая LEX_ID_TYPE - это имя переменной (type integer INTEGER)
					// В этом случае проверяем как ключевое слово
				}
				
				if (!isTypeDeclaration)
				{
					// Это имя переменной, проверяем как ключевое слово (case-insensitive)
					if (isKeyword(nameToCheck))
					{
						Log::WriteError(log.stream, Error::geterrorin(318, line, col));
						lex_ok = false;
					}
				}
			}
			else
			{
				// Для LEX_ID всегда проверяем как ключевое слово (case-insensitive)
				if (isKeyword(nameToCheck))
				{
					Log::WriteError(log.stream, Error::geterrorin(318, line, 0));
					lex_ok = false;
				}
			}
		}

		if (lex == LEX_LITERAL)
		{
			bool int_ok = IT::SetValue(itentry.get(), id);
			if (int_ok && itentry->iddatatype == IT::IDDATATYPE::INT)
			{
				char p[11];
				_itoa_s(itentry->value.vint, p, 10);
				index = getLiteralIndex(tables.idtable, p, type);
				if (index != TI_NULLIDX)
					return nullptr;
			}
			if (!int_ok)
			{
				Log::WriteError(log.stream, Error::geterrorin(313, line, col));
				lex_ok = false;
			}
			if (itentry->iddatatype == IT::IDDATATYPE::STR && itentry->value.vstr.len == 0)
			{
				Log::WriteError(log.stream, Error::geterrorin(310, line, col));
				lex_ok = false;
			}
			strcpy_s(itentry->id, SCOPED_ID_MAXSIZE, getNextLiteralName());
			itentry->idtype = IT::IDTYPE::L;
		}
		else
		{
			switch (type)
			{
			case IT::IDDATATYPE::STR:
				// vstr.str имеет размер STR_MAXSIZE - 1, но strcpy_s требует размер буфера + 1 для '\0'
				// Для пустой строки используем прямое присваивание
				itentry->value.vstr.str[0] = '\0';
				itentry->value.vstr.len = TI_STR_DEFAULT;
				break;
			case IT::IDDATATYPE::INT:
				itentry->value.vint = TI_INT_DEFAULT;
				break;
			case IT::IDDATATYPE::SYM:
				itentry->value.symbol = TI_SYM_DEFAULT;
				break;
			}

			if (isFunc)
			{
				switch (getStandFunction(id))
				{
				case IT::STDFNC::F_RANDOM:
				{
					itentry->idtype = IT::IDTYPE::S;
					itentry->iddatatype = RANDOM_TYPE;
					itentry->value.params.count = RANDOM_PARAMS_CNT;
					itentry->value.params.types = new IT::IDDATATYPE[RANDOM_PARAMS_CNT];
					for (int k = 0; k < RANDOM_PARAMS_CNT; k++)
						itentry->value.params.types[k] = IT::RANDOM_PARAMS[k];
					break;
				}
				case IT::STDFNC::F_POW:
				{
					itentry->idtype = IT::IDTYPE::S;
					itentry->iddatatype = POW_TYPE;
					itentry->value.params.count = POW_PARAMS_CNT;
					itentry->value.params.types = new IT::IDDATATYPE[POW_PARAMS_CNT];
					for (int k = 0; k < POW_PARAMS_CNT; k++)
						itentry->value.params.types[k] = IT::POW_PARAMS[k];
					break;
				}
				case IT::STDFNC::F_LENGTH:
				{
					itentry->idtype = IT::IDTYPE::S;
					itentry->iddatatype = LENGHT_TYPE;
					itentry->value.params.count = LENGHT_PARAMS_CNT;
					itentry->value.params.types = new IT::IDDATATYPE[LENGHT_PARAMS_CNT];
					for (int k = 0; k < LENGHT_PARAMS_CNT; k++)
						itentry->value.params.types[k] = IT::LENGHT_PARAMS[k];
					break;
				}
				case IT::STDFNC::F_COMPARE:
				{
					itentry->idtype = IT::IDTYPE::S;
					itentry->iddatatype = COMPARE_TYPE;
					itentry->value.params.count = COMPARE_PARAMS_CNT;
					itentry->value.params.types = new IT::IDDATATYPE[COMPARE_PARAMS_CNT];
					for (int k = 0; k < COMPARE_PARAMS_CNT; k++)
						itentry->value.params.types[k] = IT::COMPARE_PARAMS[k];
					break;
				}
				case IT::STDFNC::F_NOT_STD:
					itentry->idtype = IT::IDTYPE::F;
					break;
				}
			}
			else if (isParam)
				itentry->idtype = IT::IDTYPE::P;
			else
				itentry->idtype = IT::IDTYPE::V;

			// Для функции pow переименовываем в power
			if (itentry->idtype == IT::IDTYPE::S && getStandFunction(id) == IT::STDFNC::F_POW)
			{
				char tempId[SCOPED_ID_MAXSIZE] = { 0 };
				strcpy_s(tempId, SCOPED_ID_MAXSIZE, id);
				strcat_s(tempId, SCOPED_ID_MAXSIZE, "er");
				strcpy_s(itentry->id, SCOPED_ID_MAXSIZE, tempId);
			}
			else
			{
			strcpy_s(itentry->id, SCOPED_ID_MAXSIZE, id);
			}
		}

		int i = tables.lextable.size;

		// Проверяем ошибку 304 только если это действительно объявление переменной (type integer x = ...)
		// Не проверяем, если переменная используется в выражении (например, writeline y;)
		if (i > 1 && itentry->idtype == IT::IDTYPE::V && tables.lextable.table[i - 2].lexema != LEX_TYPE)
		{
			// Проверяем, не является ли это использованием переменной в выражении
			bool isUsage = false;
			if (i > 0)
			{
				// Если перед переменной стоит write, writeline, или оператор, это использование, а не объявление
				char prevLex = tables.lextable.table[i - 1].lexema;
				if (prevLex == LEX_WRITE || prevLex == LEX_NEWLINE || 
					prevLex == LEX_PLUS || prevLex == LEX_MINUS || prevLex == LEX_STAR || 
					prevLex == LEX_DIRSLASH || prevLex == LEX_PROCENT || prevLex == LEX_EQUAL ||
					prevLex == LEX_LEFTHESIS || prevLex == LEX_COMMA)
				{
					isUsage = true;
				}
			}
			
			if (!isUsage)
		{
			Log::WriteError(log.stream, Error::geterrorin(304, line, col));
			lex_ok = false;
			}
		}
		if (i > 1 && itentry->idtype == IT::IDTYPE::F && tables.lextable.table[i - 1].lexema != LEX_FUNCTION)
		{
			Log::WriteError(log.stream, Error::geterrorin(303, line, col));
			lex_ok = false;
		}
		// Проверяем ошибку 300 только если это действительно необъявленный идентификатор
		// Не проверяем, если это использование уже объявленной переменной
		if (itentry->iddatatype == IT::IDDATATYPE::UNDEF)
		{
			// Проверяем, не является ли это использованием уже объявленной переменной
			int existingIdx = IT::isId(tables.idtable, id);
			if (existingIdx == TI_NULLIDX)
			{
				// Это действительно необъявленный идентификатор
			Log::WriteError(log.stream, Error::geterrorin(300, line, col));
			lex_ok = false;
			}
		}

		return itentry.release();
	}

	bool analyze(LEX& tables, In::IN& in, Log::LOG& log, Parm::PARM& parm)
	{
		bool lex_ok = true;
		try
		{
			tables.lextable = LT::Create(LT_MAXSIZE);
			tables.idtable = IT::Create(MAXSIZE_TI);
		}
		catch (Error::ERROR e)
		{
			Log::WriteError(log.stream, e);
			lex_ok = false;
			return lex_ok;
		}
		bool isParam = false, isFunc = false;
		int enterPoint = 0;
		char curword[STR_MAXSIZE] = { 0 }, nextword[STR_MAXSIZE] = { 0 };
		int curline;
		std::stack<std::string> scopes;
		bool error612Reported = false; // Флаг для предотвращения дублирования ошибки 612

		for (int i = 0; i < in.words->size && lex_ok; i++)
		{
			// Используем безопасное копирование с проверкой длины
			if (in.words[i].word != nullptr)
			{
				size_t word_len = strlen(in.words[i].word);
				if (word_len >= STR_MAXSIZE)
					word_len = STR_MAXSIZE - 1;
				if (word_len > 0)
				{
					memcpy(curword, in.words[i].word, word_len);
				}
				curword[word_len] = '\0';
			}
			if (i < in.words->size - 1 && in.words[i + 1].word != nullptr)
			{
				size_t word_len = strlen(in.words[i + 1].word);
				if (word_len >= STR_MAXSIZE)
					word_len = STR_MAXSIZE - 1;
				if (word_len > 0)
				{
					memcpy(nextword, in.words[i + 1].word, word_len);
				}
				nextword[word_len] = '\0';
			}
			curline = in.words[i].line;
			int curcol = in.words[i].col; // Получаем позицию в строке
			isFunc = false;
			int idxTI = TI_NULLIDX;
			bool wordRecognized = false;

			for (int j = 0; j < N_GRAPHS && lex_ok; j++)
			{
				FST::FST fst((unsigned char*)curword, graphs[j].graph);
				if (FST::execute(fst))
				{
					wordRecognized = true;
					char lexema = graphs[j].lexema;
					
					// Если true/false распознаны как ключевые слова, но используются как литералы в присваивании
					if ((lexema == LEX_ISTRUE || lexema == LEX_ISFALSE) && i > 0 && tables.lextable.size > 0)
					{
						int lastIdx = tables.lextable.size - 1;
						// Проверяем, что предыдущая лексема - это знак равенства или разделитель
						if (tables.lextable.table[lastIdx].lexema == LEX_EQUAL || 
							tables.lextable.table[lastIdx].lexema == LEX_SEPARATOR ||
							(lastIdx > 0 && tables.lextable.table[lastIdx - 1].lexema == LEX_EQUAL))
						{
							// Обрабатываем как литерал
							lexema = LEX_LITERAL;
						}
					}
					// Если идентификатор является булевым литералом (yes, no), обрабатываем как литерал
					// Примечание: 1 и 0 уже обрабатываются как числовые литералы через GRAPH_INT_LITERAL
					if (lexema == LEX_ID && i > 0 && tables.lextable.size > 0)
					{
						int lastIdx = tables.lextable.size - 1;
						// Проверяем, что предыдущая лексема - это знак равенства
						if (tables.lextable.table[lastIdx].lexema == LEX_EQUAL)
						{
							// Проверяем, является ли это булевым литералом (только буквенные, не числовые)
							char lower[256] = { 0 };
							for (int k = 0; curword[k] != '\0' && k < 255; k++)
								lower[k] = tolower(static_cast<unsigned char>(curword[k]));
							
							// Проверяем только буквенные булевые литералы (yes, no, true, false, on, off)
							// Числовые (1, 0) уже обрабатываются как числовые литералы
							if (strcmp(lower, "yes") == 0 || strcmp(lower, "no") == 0 || 
								strcmp(lower, "true") == 0 || strcmp(lower, "false") == 0 ||
								strcmp(lower, "on") == 0 || strcmp(lower, "off") == 0)
							{
								// Обрабатываем как литерал
								lexema = LEX_LITERAL;
							}
						}
					}
					switch (lexema)
					{
					case LEX_MAIN:
						enterPoint++;
						// Проверка ошибки 600: main main { ... } - два main подряд
						if (i > 0 && tables.lextable.size > 0)
						{
							int lastIdx = tables.lextable.size - 1;
							if (lastIdx >= 0 && tables.lextable.table[lastIdx].lexema == LEX_MAIN)
							{
								Log::WriteError(log.stream, Error::geterrorin(600, curline, curcol));
								lex_ok = false;
							}
						}
						break;
					case LEX_SEPARATORS:
					{
						// Устанавливаем лексему как LEX_SUBST для @, если это @
						if (curword != nullptr && curword[0] == '@' && strlen(curword) == 1)
						{
							lexema = LEX_SUBST;
						}
						
						switch (*curword)
						{
						case LEX_LEFTHESIS:
						{
							isParam = true;
							// Проверка ошибки 601: pow() - пустые параметры функции
							if (*nextword == LEX_RIGHTTHESIS)
							{
								// Проверяем, что перед ( стоит идентификатор функции
								if (i > 0 && tables.lextable.size > 0)
								{
									int lastIdx = tables.lextable.size - 1;
									if (lastIdx >= 0 && (tables.lextable.table[lastIdx].lexema == LEX_ID || 
										tables.lextable.table[lastIdx].lexema == LEX_STDFUNC || 
										tables.lextable.table[lastIdx].lexema == LEX_ID_TYPE))
									{
										// Это вызов функции с пустыми параметрами - ошибка 601
										Log::WriteError(log.stream, Error::geterrorin(601, curline, curcol));
										lex_ok = false;
									}
								}
							}
							// Проверка ошибки 604: lenght(,) - запятая без параметра
							if (i + 1 < in.words->size && in.words[i + 1].word != nullptr && 
								in.words[i + 1].word[0] == LEX_COMMA)
							{
								Log::WriteError(log.stream, Error::geterrorin(604, curline, curcol));
								lex_ok = false;
							}
							if (*nextword == LEX_RIGHTTHESIS || ISTYPE(nextword))
							{
								const char* scopename = getScopeName(tables.idtable, in.words[i - 1].word);
								if (scopename == nullptr)
									break;
								scopes.push(std::string(scopename));
							}
							break;
						}
						case LEX_COMMA:
						{
							// Проверка ошибки 604: lenght(,) или lenght(x,,) - две запятые подряд или запятая в начале
							if (i > 0 && tables.lextable.size > 0)
							{
								int lastIdx = tables.lextable.size - 1;
								// Если перед запятой стоит ( или , - это ошибка
								if (lastIdx >= 0 && (tables.lextable.table[lastIdx].lexema == LEX_LEFTHESIS || 
									(i > 1 && in.words[i - 1].word != nullptr && in.words[i - 1].word[0] == LEX_COMMA)))
								{
									Log::WriteError(log.stream, Error::geterrorin(604, curline, curcol));
									lex_ok = false;
								}
							}
							// Если после запятой сразу идет ) или , - это тоже ошибка
							if (i + 1 < in.words->size && in.words[i + 1].word != nullptr)
							{
								if (in.words[i + 1].word[0] == LEX_RIGHTTHESIS || 
									in.words[i + 1].word[0] == LEX_COMMA)
								{
									Log::WriteError(log.stream, Error::geterrorin(604, curline, curcol));
									lex_ok = false;
								}
							}
							break;
						}
						case LEX_RIGHTTHESIS:
						{
							isParam = false;
							if (*in.words[i - 1].word == LEX_LEFTHESIS || (i > 2 && (tables.lextable.table[tables.lextable.size - 2].lexema == LEX_ID_TYPE)))
								if (!scopes.empty())
									scopes.pop();
							break;
						}
						case LEX_EQUAL: // =
						{
							// Проверка ошибок 612 и 615 выполняется после создания ltentry
							break;
						}
						case LEX_SEPARATOR: // ;
						{
							// Проверка ошибок 612 и 615 выполняется после создания ltentry
							break;
						}
						case LEX_SUBST:
						{
							// Лексема уже установлена как LEX_SUBST в case LEX_SEPARATORS
							break;
						}
					case LEX_LEFTBRACE:
					{
						// Проверяем, что есть предыдущее слово
						if (i == 0)
						{
							Log::WriteError(log.stream, Error::geterrorin(205, curline, curcol));
							lex_ok = false;
							break;
						}
						
						const char* scopename = getScopeName(tables.idtable, in.words[i - 1].word);
						if (scopename == nullptr)
						{
							// Если не найдено имя области видимости (нет main или функции перед {)
							Log::WriteError(log.stream, Error::geterrorin(205, curline, curcol));
							lex_ok = false;
							break;
						}
						scopes.push(std::string(scopename));
						break;
					}
					case LEX_BRACELET:
					{
						// Закрывающая скобка всегда удаляет область видимости из стека
						if (!scopes.empty())
							scopes.pop();
						break;
					}
						case LEX_INCR:
						{
							int index = IT::isId(tables.idtable, curword);
							std::unique_ptr<IT::Entry> itentry = std::make_unique<IT::Entry>();
							if (index != TI_NULLIDX)
							{
								idxTI = index;
							}
							else
							{
								memset(itentry->id, 0, SCOPED_ID_MAXSIZE);
								strcpy_s(itentry->id, SCOPED_ID_MAXSIZE, curword);
								itentry->idtype = IT::IDTYPE::Z;
								itentry->iddatatype = IT::IDDATATYPE::INT;
								itentry->idxfirstLE = getIndexInLT(tables.lextable, index);
								try
								{
									IT::Add(tables.idtable, *itentry);
								}
								catch (Error::ERROR e)
								{
									Log::WriteError(log.stream, e);
									lex_ok = false;
									return lex_ok;
								}
								idxTI = tables.idtable.size - 1;
							}
							lexema = *curword;
							break;
						}
						}
						lexema = *curword;
						break;
					}

					case LEX_ID_TYPE:
					{
						// Обработка LEX_ID_TYPE (integer, string, symbol или имя переменной, которое совпадает с ключевым словом)
						char id[STR_MAXSIZE] = { 0 };
						idxTI = TI_NULLIDX;

						// Проверяем контекст: если перед LEX_ID_TYPE стоит LEX_TYPE, то это тип данных, иначе - имя переменной
						bool isTypeData = false;
						if (tables.lextable.size > 0)
						{
							int lastIdx = tables.lextable.size - 1;
							if (lastIdx >= 0 && tables.lextable.table[lastIdx].lexema == LEX_TYPE)
							{
								// Это тип данных (type integer), не обрабатываем как переменную
								isTypeData = true;
							}
						}

						if (!isTypeData)
						{
							// Это имя переменной, обрабатываем аналогично LEX_ID
							if (*nextword == LEX_LEFTHESIS || IT::isId(tables.idtable, curword) != TI_NULLIDX)
							{
								isFunc = true;
								if (getStandFunction(curword) == IT::STDFNC::F_NOT_STD)
									strcat_s(id, STR_MAXSIZE, "_");
							}

							const char* idtype = (isFunc && i > 1) ? in.words[i - 2].word : in.words[i - 1].word;
							if (i == 0)
								idtype = nullptr;

							if (!isFunc && !scopes.empty())
								strcpy_s(id, STR_MAXSIZE, scopes.top().c_str());

							strcat_s(id, STR_MAXSIZE, curword);

							if (isLiteral(curword))
								strcpy_s(id, STR_MAXSIZE, curword);

							IT::Entry* itentry = getEntry(tables, lexema, id, idtype, isParam, isFunc, log, curline, curcol, lex_ok, curword);
							if (itentry != nullptr)
							{
								if (isFunc)
								{
									itentry->value.params.count = 0;
									itentry->value.params.types = new IT::IDDATATYPE[MAX_PARAMS_COUNT];
									for (int k = i; k < in.words->size && in.words[k].word[0] != LEX_RIGHTTHESIS; k++)
									{
										if (in.words[k].word[0] == LEX_SEPARATOR)
											break;
										if (ISTYPE(in.words[k].word))
										{
											if (itentry->value.params.count >= MAX_PARAMS_COUNT)
											{
												Log::WriteError(log.stream, Error::geterrorin(306, curline, curcol));
												lex_ok = false;
												break;
											}
											itentry->value.params.types[itentry->value.params.count++] = getType(nullptr, in.words[k].word);
										}
									}
								}
								try
								{
									IT::Add(tables.idtable, *itentry);
								}
								catch (Error::ERROR e)
								{
									Log::WriteError(log.stream, e);
									lex_ok = false;
									delete itentry;
									return lex_ok;
								}
								idxTI = tables.idtable.size - 1;
								delete itentry;
							}
							else
							{
								int lt_index = tables.lextable.size - 1;
								if (lt_index > 0 && (tables.lextable.table[lt_index - 1].lexema == LEX_TYPE || tables.lextable.table[lt_index].lexema == LEX_TYPE
									|| tables.lextable.table[lt_index - 1].lexema == LEX_FUNCTION || tables.lextable.table[lt_index].lexema == LEX_FUNCTION
									|| tables.lextable.table[lt_index - 1].lexema == LEX_ID_TYPE || tables.lextable.table[lt_index].lexema == LEX_ID_TYPE
									|| tables.lextable.table[lt_index - 1].lexema == LEX_VOID || tables.lextable.table[lt_index].lexema == LEX_VOID))
								{
									Log::WriteError(log.stream, Error::geterrorin(305, curline, curcol));
									lex_ok = false;
								}
								if (lexema == LEX_LITERAL)
								{
									idxTI = getLiteralIndex(tables.idtable, curword, getType(id, idtype));
								}
								else
								{
									idxTI = IT::isId(tables.idtable, id);
								}
							}
						}
						break;
					}

					case LEX_ID:
					case LEX_STDFUNC:
					case LEX_LITERAL:
					{
						char id[STR_MAXSIZE] = { 0 };
						idxTI = TI_NULLIDX;

						if (*nextword == LEX_LEFTHESIS || IT::isId(tables.idtable, curword) != TI_NULLIDX)
						{
							isFunc = true;
							if (getStandFunction(curword) == IT::STDFNC::F_NOT_STD)
								strcat_s(id, STR_MAXSIZE, "_");
						}

						const char* idtype = (isFunc && i > 1) ? in.words[i - 2].word : in.words[i - 1].word;
						if (i == 0)
							idtype = nullptr;

						if (!isFunc && !scopes.empty())
							strcpy_s(id, STR_MAXSIZE, scopes.top().c_str());

						strcat_s(id, STR_MAXSIZE, curword);

						if (isLiteral(curword))
							strcpy_s(id, STR_MAXSIZE, curword);

						IT::Entry* itentry = getEntry(tables, lexema, id, idtype, isParam, isFunc, log, curline, curcol, lex_ok, curword);
						if (itentry != nullptr)
						{
							if (isFunc)
							{
								itentry->value.params.count = 0;
								itentry->value.params.types = new IT::IDDATATYPE[MAX_PARAMS_COUNT];
								for (int k = i; k < in.words->size && in.words[k].word[0] != LEX_RIGHTTHESIS; k++)
								{
									if (in.words[k].word[0] == LEX_SEPARATOR)
										break;
									if (ISTYPE(in.words[k].word))
									{
										if (itentry->value.params.count >= MAX_PARAMS_COUNT)
										{
											Log::WriteError(log.stream, Error::geterrorin(306, curline, curcol));
											lex_ok = false;
											break;
										}
										itentry->value.params.types[itentry->value.params.count++] = getType(nullptr, in.words[k].word);
									}
								}
							}
							try
							{
								IT::Add(tables.idtable, *itentry);
							}
							catch (Error::ERROR e)
							{
								Log::WriteError(log.stream, e);
								lex_ok = false;
								delete itentry;
								return lex_ok;
							}
							idxTI = tables.idtable.size - 1;
							delete itentry;
						}
						else
						{
							int lt_index = tables.lextable.size - 1;
							if (lt_index > 0 && (tables.lextable.table[lt_index - 1].lexema == LEX_TYPE || tables.lextable.table[lt_index].lexema == LEX_TYPE
								|| tables.lextable.table[lt_index - 1].lexema == LEX_FUNCTION || tables.lextable.table[lt_index].lexema == LEX_FUNCTION
								|| tables.lextable.table[lt_index - 1].lexema == LEX_ID_TYPE || tables.lextable.table[lt_index].lexema == LEX_ID_TYPE
								|| tables.lextable.table[lt_index - 1].lexema == LEX_VOID || tables.lextable.table[lt_index].lexema == LEX_VOID))
							{
								Log::WriteError(log.stream, Error::geterrorin(305, curline, curcol));
								lex_ok = false;
							}
							if (lexema == LEX_LITERAL)
							{
								idxTI = getLiteralIndex(tables.idtable, curword, getType(id, idtype));
							}
							else
							{
								idxTI = IT::isId(tables.idtable, id);
							}
						}
						break;
					}
					}

					LT::Entry ltentry(lexema, curline, curcol, idxTI);
					
					// Проверка ошибки 610: неверный арифметический оператор (@ используется как арифметический оператор)
					// Выполняем проверку здесь, после создания ltentry, но перед добавлением в таблицу
					// Проверяем по символу @ независимо от того, как он распознан
					if (curword != nullptr && curword[0] == '@' && strlen(curword) == 1)
					{
						// @ используется только для вызова функции в польской записи, не как арифметический оператор
						// Проверяем, что @ не используется как арифметический оператор (x @ 5)
						if (i > 0 && i + 1 < in.words->size && in.words[i + 1].word != nullptr && in.words[i - 1].word != nullptr)
						{
							char nextChar = in.words[i + 1].word[0];
							char prevChar = in.words[i - 1].word[0];
							
							// Проверяем, что перед @ стоит идентификатор или литерал (начинается с буквы, цифры, кавычки или минуса)
							bool hasValidPredecessor = (isalpha(static_cast<unsigned char>(prevChar)) || 
								isdigit(static_cast<unsigned char>(prevChar)) || 
								prevChar == IN_CODE_QUOTE || prevChar == IN_CODE_APOST || prevChar == LEX_MINUS);
							
							// Если перед @ стоит идентификатор/литерал, и после @ идет литерал или идентификатор - это ошибка
							if (hasValidPredecessor)
							{
								// Проверяем, что после @ идет литерал или идентификатор (цифра, буква, кавычка или минус)
								if (isdigit(static_cast<unsigned char>(nextChar)) || isalpha(static_cast<unsigned char>(nextChar)) ||
									nextChar == IN_CODE_QUOTE || nextChar == IN_CODE_APOST || nextChar == LEX_MINUS)
								{
									// @ используется как арифметический оператор - ошибка 610
									Log::WriteError(log.stream, Error::geterrorin(610, curline, curcol));
									lex_ok = false;
								}
							}
						}
						// Устанавливаем лексему как LEX_SUBST для дальнейшей обработки
						lexema = LEX_SUBST;
						ltentry.lexema = LEX_SUBST;
					}
					
					
					// Проверка ошибки 303: после type и типа данных должно быть имя переменной
					if (lexema == LEX_ID_TYPE && tables.lextable.size > 0)
					{
						// Проверяем, что предыдущая лексема - это type
						if (tables.lextable.table[tables.lextable.size - 1].lexema == LEX_TYPE)
						{
							// Проверяем, что следующее слово - это не идентификатор, а сразу ; или }
							if (i + 1 < in.words->size)
							{
								char nextChar = in.words[i + 1].word[0];
								if (nextChar == LEX_SEPARATOR || nextChar == LEX_BRACELET)
								{
									// type integer; - отсутствует имя идентификатора
									Log::WriteError(log.stream, Error::geterrorin(303, curline, curcol));
									lex_ok = false;
								}
							}
							// Если следующего слова нет (конец файла), это тоже ошибка
							else
							{
								Log::WriteError(log.stream, Error::geterrorin(303, curline, curcol));
								lex_ok = false;
							}
						}
					}
					// Проверка ошибки 602: незавершенный type (type без типа данных или имени переменной)
					if (lexema == LEX_TYPE)
					{
						// Проверяем, что после type есть тип данных
						if (i + 1 >= in.words->size)
						{
							// type в конце файла - ошибка
							Log::WriteError(log.stream, Error::geterrorin(602, curline, curcol));
							lex_ok = false;
						}
						else if (i + 1 < in.words->size)
						{
							char nextChar = in.words[i + 1].word[0];
							// Если после type сразу ; или } - это ошибка
							if (nextChar == LEX_SEPARATOR || nextChar == LEX_BRACELET)
							{
								Log::WriteError(log.stream, Error::geterrorin(602, curline, curcol));
								lex_ok = false;
							}
						}
					}
					// Проверка ошибки 605: ошибка в условии цикла repeat x times do { ... }
					if (lexema == LEX_REPEAT)
					{
						// Проверяем структуру: repeat <идентификатор/литерал> times do { ... }
						if (i + 1 >= in.words->size)
						{
							// repeat в конце файла - ошибка
							Log::WriteError(log.stream, Error::geterrorin(605, curline, curcol));
							lex_ok = false;
						}
						else if (i + 1 < in.words->size && in.words[i + 1].word != nullptr)
						{
							// Проверяем, что после repeat есть идентификатор или литерал
							char nextChar = in.words[i + 1].word[0];
							// Если следующее слово - это ключевое слово times, do или разделитель - ошибка
							if (nextChar == LEX_TIMES || nextChar == LEX_DO || 
								nextChar == LEX_SEPARATOR || nextChar == LEX_BRACELET ||
								nextChar == LEX_SQ_LBRACELET || nextChar == LEX_LEFTBRACE)
							{
								// После repeat сразу times, do, ;, } или [ - ошибка
								Log::WriteError(log.stream, Error::geterrorin(605, curline, curcol));
								lex_ok = false;
							}
						}
					}
					if (lexema == LEX_TIMES)
					{
						// Проверяем, что перед times стоит идентификатор или литерал
						bool hasValidPredecessor = false;
						if (i > 0 && tables.lextable.size > 0)
						{
							int lastIdx = tables.lextable.size - 1;
							if (lastIdx >= 0 && (tables.lextable.table[lastIdx].lexema == LEX_ID || 
								tables.lextable.table[lastIdx].lexema == LEX_LITERAL ||
								tables.lextable.table[lastIdx].lexema == LEX_ID_TYPE))
							{
								hasValidPredecessor = true;
							}
						}
						if (!hasValidPredecessor)
						{
							// Перед times должен быть идентификатор или литерал
							Log::WriteError(log.stream, Error::geterrorin(605, curline, curcol));
							lex_ok = false;
						}
						// Проверяем, что после times стоит do
						if (i + 1 >= in.words->size)
						{
							// times в конце файла - ошибка
							Log::WriteError(log.stream, Error::geterrorin(605, curline, curcol));
							lex_ok = false;
						}
						else if (i + 1 < in.words->size && in.words[i + 1].word != nullptr)
						{
							char nextChar = in.words[i + 1].word[0];
							if (nextChar != LEX_DO)
							{
								// После times должно быть do
								Log::WriteError(log.stream, Error::geterrorin(605, curline, curcol));
								lex_ok = false;
							}
						}
					}
					// Дополнительная проверка: если после идентификатора/литерала сразу идет do (без times)
					// Это нужно проверить для случая repeat x do
					if ((lexema == LEX_ID || lexema == LEX_LITERAL || lexema == LEX_ID_TYPE) && 
						i + 1 < in.words->size && in.words[i + 1].word != nullptr)
					{
						char nextChar = in.words[i + 1].word[0];
						// Если после идентификатора/литерала идет do, проверяем контекст
						if (nextChar == LEX_DO)
						{
							// Проверяем, что перед идентификатором был repeat
							if (i > 0 && tables.lextable.size > 0)
							{
								int lastIdx = tables.lextable.size - 1;
								if (lastIdx >= 0 && tables.lextable.table[lastIdx].lexema == LEX_REPEAT)
								{
									// repeat x do - отсутствует times между x и do
									Log::WriteError(log.stream, Error::geterrorin(605, curline, curcol));
									lex_ok = false;
								}
							}
						}
					}
					if (lexema == LEX_DO)
					{
						// Проверяем, что перед do стоит times
						bool hasTimesBefore = false;
						if (i > 0 && tables.lextable.size > 0)
						{
							int lastIdx = tables.lextable.size - 1;
							if (lastIdx >= 0 && tables.lextable.table[lastIdx].lexema == LEX_TIMES)
							{
								hasTimesBefore = true;
							}
							// Также проверяем, что перед do не стоит идентификатор или литерал напрямую (без times)
							// Это означает, что структура repeat x do неправильная (должно быть repeat x times do)
							else if (lastIdx >= 0 && (tables.lextable.table[lastIdx].lexema == LEX_ID || 
								tables.lextable.table[lastIdx].lexema == LEX_LITERAL ||
								tables.lextable.table[lastIdx].lexema == LEX_ID_TYPE))
							{
								// Перед do стоит идентификатор/литерал, но не times - это ошибка
								// Проверяем, что перед этим идентификатором был repeat
								if (lastIdx > 0 && tables.lextable.table[lastIdx - 1].lexema == LEX_REPEAT)
								{
									// repeat x do - отсутствует times
									Log::WriteError(log.stream, Error::geterrorin(605, curline, curcol));
									lex_ok = false;
								}
							}
						}
						if (!hasTimesBefore && lex_ok)
						{
							// Перед do должно быть times (если ошибка еще не была выведена выше)
							Log::WriteError(log.stream, Error::geterrorin(605, curline, curcol));
							lex_ok = false;
						}
						// Проверяем, что после do есть открывающая скобка [ или {
						if (i + 1 >= in.words->size)
						{
							// do в конце файла - ошибка
							Log::WriteError(log.stream, Error::geterrorin(605, curline, curcol));
							lex_ok = false;
						}
						else if (i + 1 < in.words->size && in.words[i + 1].word != nullptr)
						{
							char nextChar = in.words[i + 1].word[0];
							if (nextChar != LEX_SQ_LBRACELET && nextChar != LEX_LEFTBRACE)
							{
								// После do должна быть открывающая скобка [ или {
								Log::WriteError(log.stream, Error::geterrorin(605, curline, curcol));
								lex_ok = false;
							}
						}
					}
					
					// Проверка ошибки 611: ошибка в арифметическом выражении (оператор без операнда)
					if (lexema == LEX_PLUS || lexema == LEX_MINUS || lexema == LEX_STAR || 
						lexema == LEX_DIRSLASH || lexema == LEX_PROCENT)
					{
						// Проверяем, что после арифметического оператора есть операнд
						if (i + 1 >= in.words->size)
						{
							// Оператор в конце файла - ошибка
							Log::WriteError(log.stream, Error::geterrorin(611, curline, curcol));
							lex_ok = false;
						}
						else if (i + 1 < in.words->size && in.words[i + 1].word != nullptr)
						{
							char nextChar = in.words[i + 1].word[0];
							// Если после оператора идет ; или } - это ошибка
							if (nextChar == LEX_SEPARATOR || nextChar == LEX_BRACELET || 
								nextChar == LEX_SQ_RBRACELET)
							{
								// Оператор без операнда - ошибка 611
								Log::WriteError(log.stream, Error::geterrorin(611, curline, curcol));
								lex_ok = false;
							}
						}
					}
					// Проверка ошибки 612 и 615: недопустимая синтаксическая конструкция (x = y =; или x =;)
					// Проверяем как по лексеме, так и по символу =
					// Проверяем только для первого = в паре, чтобы избежать дублирования
					if (!error612Reported && (lexema == LEX_EQUAL || (curword != nullptr && curword[0] == LEX_EQUAL && strlen(curword) == 1)))
					{
						// Проверяем, что перед текущим = НЕ стоит другой = (чтобы избежать проверки второго = в паре)
						bool isFirstEqual = true;
						if (i > 0 && tables.lextable.size > 0)
						{
							int lastIdx = tables.lextable.size - 1;
							if (lastIdx >= 0 && tables.lextable.table[lastIdx].lexema == LEX_EQUAL)
							{
								// Перед текущим = стоит другой = - это второй = в паре, пропускаем проверку
								isFirstEqual = false;
							}
						}
						
						if (isFirstEqual)
						{
							// Проверяем, что после = есть значение
							if (i + 1 >= in.words->size)
							{
								// = в конце файла - ошибка
								Log::WriteError(log.stream, Error::geterrorin(615, curline, curcol));
								lex_ok = false;
							}
							else if (i + 1 < in.words->size && in.words[i + 1].word != nullptr)
							{
								char nextChar = in.words[i + 1].word[0];
								
								// Если после = идет еще один = - это ошибка (x = y =;)
								if (nextChar == LEX_EQUAL || (in.words[i + 1].word != nullptr && in.words[i + 1].word[0] == '='))
								{
									// Проверяем, что после второго = идет ; или }
									if (i + 2 < in.words->size && in.words[i + 2].word != nullptr)
									{
										char nextNextChar = in.words[i + 2].word[0];
										if (nextNextChar == LEX_SEPARATOR || nextNextChar == LEX_BRACELET ||
											nextNextChar == LEX_SQ_RBRACELET)
										{
											// x = y =; - недопустимая синтаксическая конструкция
											// Выводим ошибку только один раз
											if (!error612Reported)
											{
												Log::WriteError(log.stream, Error::geterrorin(612, curline, curcol));
												lex_ok = false;
												error612Reported = true; // Предотвращаем дублирование ошибки
											}
										}
									}
									else if (i + 2 >= in.words->size)
									{
										// x = y = в конце файла - ошибка 612
										// Выводим ошибку только один раз
										if (!error612Reported)
										{
											Log::WriteError(log.stream, Error::geterrorin(612, curline, curcol));
											lex_ok = false;
											error612Reported = true; // Предотвращаем дублирование ошибки
										}
									}
								}
								// Если после = идет ; или } - это ошибка (ожидался литерал или идентификатор)
								else if (nextChar == LEX_SEPARATOR || nextChar == LEX_BRACELET || 
									nextChar == LEX_SQ_RBRACELET)
								{
									// = без значения - ошибка 615 (или 617, если в теле цикла)
									// Проверяем, находимся ли мы в теле цикла
									bool inLoop = false;
									// Проверяем, есть ли в стеке областей видимости что-то связанное с циклом
									// Для простоты проверяем, что перед = был repeat или do
									if (i > 0 && tables.lextable.size > 0)
									{
										// Ищем в последних лексемах repeat или do
										for (int k = tables.lextable.size - 1; k >= 0 && k >= tables.lextable.size - 10; k--)
										{
											if (tables.lextable.table[k].lexema == LEX_REPEAT || 
												tables.lextable.table[k].lexema == LEX_DO)
											{
												inLoop = true;
												break;
											}
											// Если встретили закрывающую скобку цикла, выходим из поиска
											if (tables.lextable.table[k].lexema == LEX_SQ_RBRACELET || 
												tables.lextable.table[k].lexema == LEX_BRACELET)
											{
												break;
											}
										}
									}
									if (inLoop)
									{
										// Ошибка в теле цикла - ошибка 617
										Log::WriteError(log.stream, Error::geterrorin(617, curline, curcol));
									}
									else
									{
										// Ошибка 615
										Log::WriteError(log.stream, Error::geterrorin(615, curline, curcol));
									}
									lex_ok = false;
								}
							}
						}
					}
					// Проверка ошибки 617: ошибка в теле цикла (type integer y =;)
					// Эта проверка выполняется для случая, когда в теле цикла есть = без значения
					// Проверка уже выполнена выше для LEX_EQUAL, но нужно убедиться, что она работает в теле цикла
					
					try
					{
						LT::Add(tables.lextable, ltentry);
					}
					catch (Error::ERROR e)
					{
						Log::WriteError(log.stream, e);
						lex_ok = false;
						return lex_ok;
					}
					break;
				}
			}
			
			// Проверяем, было ли слово распознано, только после проверки всех графов
			if (!wordRecognized)
			{
				// Проверяем, что это не пустое слово или пробел
				if (curword != nullptr && strlen(curword) > 0 && curword[0] != ' ' && curword[0] != '\t' && curword[0] != '\0')
				{
					// Выводим ошибку только один раз для каждого нераспознанного слова
					Log::WriteError(log.stream, Error::geterrorin(201, curline, curcol));
					lex_ok = false;
				}
			}
		}

		if (enterPoint == 0)
		{
			Log::WriteError(log.stream, Error::geterror(301));
			lex_ok = false;
		}
		if (enterPoint > 1)
		{
			Log::WriteError(log.stream, Error::geterror(302));
			lex_ok = false;
		}
		
		// Проверяем, что все открытые блоки закрыты
		if (!scopes.empty())
		{
			Log::WriteError(log.stream, Error::geterror(618));
			lex_ok = false;
		}

		return lex_ok;
	}
}

file Log.cpp:
#include "pch.h"
namespace Log
{

	LOG getlog(wchar_t logfile[])
	{
		LOG temp;
		temp.stream = new std::ofstream(logfile);					//динамическое выделение ofstream и инициализация указателя на этот объект и открытие
		if (!temp.stream->is_open())
			throw ERROR_THROW(112);
		wcscpy_s(temp.logfile, logfile);							//копирование logfile в temp.logfile
		return temp;
	}

	void WriteLine(LOG log, const char * c, ...)
	{
		const char **ptr = &c;										//берем адрес-адреса
		while (strlen(*ptr) > 0)										//пока не встретим L""
		{
			*log.stream << *ptr;									// запись в файл параметра
			++ptr;													//перемещаемся на следующий параметр
		}
		*log.stream << std::endl;
	}
	void WriteLineConsole(char * c, ...)
	{
		char** ptr = &c;			// указатель для доступа к параметрам
		char* result = nullptr;		// строка результата
		size_t size = 0;
		size_t capacity = 15;
		result = new char[capacity];
		result[0] = '\0';
		
		while (strcmp(*ptr, "") != 0)
		{
			size_t slen = strlen(*ptr);
			// Проверяем, нужно ли увеличить буфер
			if (size + slen + 1 >= capacity)
			{
				// Увеличиваем capacity с запасом
				capacity = (size + slen + 1) * 2;
				char* new_result = new char[capacity];
				// Копируем существующие данные
				size_t old_size = strlen(result);
				strcpy_s(new_result, capacity, result);
				delete[] result;
				result = new_result;
			}
			strcat_s(result, capacity, *ptr);
			size = strlen(result); // Обновляем текущий размер
			ptr++;
		}
		std::cout << result << std::endl;
		delete[] result; // Освобождаем память
	}

	void WriteLine(LOG log, const wchar_t * c, ...)
	{
		const wchar_t **ptr = &c;
		while (wcslen(*ptr))
		{
			char out[PARM_MAX_SIZE];
			size_t charsConverted = 0;								//функция преобразовавающая wchar_t* в char
			wcstombs_s(&charsConverted, out, *ptr, PARM_MAX_SIZE);	// 1-ый аргумент: Размер в байтах преобразованной строки, включая нулевой терминатор 2-
			*log.stream << out;										// запись в файл параметра	
			++ptr;
		}
		*log.stream << std::endl;
	}

	void WriteLog(LOG log)
	{
		time_t  t = time(nullptr);									// time_t = количество секунд time()- Текущее календарное время типа c 1 января 1970 
		tm  now ;														// структура содержащая сек мин час ...
		localtime_s(&now, &t);										//Преобразует time_t в календарное время, выраженное в местном времени в хранилище struct tm
		char date[PARM_MAX_SIZE];									//массив для вывода времени
		strftime(date, PARM_MAX_SIZE, "%d.%m.%Y %H:%M:%S", &now);	//фукнция преобразующая структуру tm в массив c макс кол-вом символов для копирования PARM_MAX_SIZE в формате day month year...
		*log.stream << "---- Протокол ------- Дата: " << date << std::endl;
	}

	void WriteParm(LOG log, Parm::PARM parm)
	{
		*log.stream << "---- Параметры -------" << std::endl;
		char out[PARM_MAX_SIZE];
		size_t charsConverted(0);
		wcstombs_s(&charsConverted, out, parm.log, PARM_MAX_SIZE);
		*log.stream << "-log: " << out << std::endl;
		wcstombs_s(&charsConverted, out, parm.out, PARM_MAX_SIZE);
		*log.stream << "-out: " << out << std::endl;
		wcstombs_s(&charsConverted, out, parm.in, PARM_MAX_SIZE);
		*log.stream << "-in: " << out << std::endl;
	}

	void WriteIn(LOG log, In::IN in)
	{
		*log.stream << "---- Исходные данные -----" << std::endl;
		*log.stream << "Количество символов: " << in.size << std::endl;
		*log.stream << "Проигнорировано:     " << in.ignor << std::endl;
		*log.stream << "Количество строк:    " << in.lines << std::endl;
	}
	void WriteError(std::ostream *stream, Error::ERROR e)
	{
		if (stream == nullptr || stream == NULL)
		{
			if (e.position.col == -1 || e.position.line == -1)
				std::cout << std::endl << "Ошибка N" << e.id << ": " << e.message << std::endl;
			else
				std::cout << std::endl << "Ошибка N" << e.id << ": " << e.message
				<< " Строка: " << e.position.line
				<< " Позиция в строке: " << e.position.col << std::endl;
			system("pause");
		}
		else
		{
			try
			{
				if (e.position.col == -1 || e.position.line == -1)
					*stream << std::endl << "Ошибка N" << e.id << ": " << e.message;
				else
					*stream << std::endl << "Ошибка N" << e.id << ": " << e.message
					<< " Строка: " << e.position.line
					<< " Позиция в строке: " << e.position.col;
				*stream << std::endl;
			}
			catch (...)
			{
				// Если произошла ошибка при записи в поток, выводим в консоль
				if (e.position.col == -1 || e.position.line == -1)
					std::cout << std::endl << "Ошибка N" << e.id << ": " << e.message << std::endl;
				else
					std::cout << std::endl << "Ошибка N" << e.id << ": " << e.message
					<< " Строка: " << e.position.line
					<< " Позиция в строке: " << e.position.col << std::endl;
			}
		}
	}

	void Close(LOG log)
	{
		if (log.stream != nullptr)									//если поток открыт
		{
			log.stream->close();
			delete log.stream;
		}
	}

}

file LT.cpp:
#include "pch.h"
namespace LT
{
	Entry::Entry()
	{
		lexema = NULL;
		sn = NULL;
		col = 0;
		idxTI = NULLDX_TI;
	}

	Entry::Entry(unsigned char lexema, int snn, int coln, int idxti)
	{
		this->lexema = lexema;
		this->sn = snn;
		this->col = coln;
		this->idxTI = idxti;
	}

	LexTable Create(int size)
	{
		if (size > LT_MAXSIZE)
		{
			Error::ERROR err = Error::geterror(202);
			throw err;
		}
		LexTable lextable;
		lextable.table = new Entry[lextable.maxsize = size];
		lextable.size = 0;
		return  lextable;
	}

	void Add(LexTable &lextable, Entry entry)
	{
		if (lextable.size >= lextable.maxsize)
		{
			Error::ERROR err = Error::geterrorin(202, entry.sn, entry.col);
			throw err;
		}
		lextable.table[lextable.size++] = entry;
	}
	void writeLexTable(std::ostream* stream, LT::LexTable& lextable)
	{
		*stream << "------------------------------ ТАБЛИЦА ЛЕКСЕМ  ------------------------\n" << std::endl;
		*stream << "|  N | ЛЕКСЕМА | СТРОКА | ИНДЕКС В ТИ |" << std::endl;
		for (int i = 0; i < lextable.size; i++)
		{
			if (lextable.table[i].lexema == '#')
				continue;
			*stream << "|" << std::setw(3) << i << " | " << std::setw(4) << lextable.table[i].lexema << "    |  " << std::setw(3)
				<< lextable.table[i].sn << "   |";
			if (lextable.table[i].idxTI == -1)
				*stream << "             |" << std::endl;
			else
				*stream << std::setw(8) << lextable.table[i].idxTI << "     |" << std::endl;
		}
	}

	void writeLexemsOnLines(std::ostream* stream, LT::LexTable& lextable)
	{
		bool flagtemp = false;
		*stream << "\n-----------------  ЛЕКСЕМЫ СООТВЕТСТВУЮЩИЕ ИСХОДНОМУ КОДУ ---------------------\n" << std::endl;
		for (int i = 0; i < lextable.size; )
		{
			if (lextable.table[i].lexema == '#')
			{
				flagtemp = true;
				i++;
				continue;
			}
			if (flagtemp)
			{
				flagtemp = false;
				*stream << lextable.table[i].lexema;
				*stream << std::endl;
				i++;
				continue;
			}
			int line = lextable.table[i].sn;
			*stream << std::setw(3) << line << " | ";
			while (lextable.table[i].sn == line)
			{
				*stream << lextable.table[i].lexema;
				if (lextable.table[i].idxTI != NULLDX_TI)
					*stream << "[" << lextable.table[i].idxTI << "]";
				i++;
			}
			if(lextable.table[i].lexema != '#')
			*stream << std::endl;
		}
		*stream << "-------------------------------------------------------------------------\n\n";
	}
}

file MFST.cpp:
#include "pch.h"
#include <climits>
#define NS(n)	GRB::Rule::Chain::N(n)
#define TS(n)	GRB::Rule::Chain::T(n)
#define ISNS(n)	GRB::Rule::Chain::isN(n)
int FST_TRACE_n = -1;
char rbuf[205],		// для правила
sbuf[205],		// для стека
lbuf[1024];	// для ленты

namespace MFST
{
	MfstState::MfstState() //конструктор
	{
		lenta_position = 0;
		nrule = -1;
		nrulechain = -1;
	};

	MfstState::MfstState(short pposition, MFSTSTACK pst, short pnrulechain) //конструктор
	{
		lenta_position = pposition;
		st = pst;
		nrulechain = pnrulechain;
	};

	MfstState::MfstState(short pposition, MFSTSTACK pst, short pnrule, short pnrulechain)		// конструктор запоминаем правило
	{
		lenta_position = pposition;
		st = pst;
		nrule = pnrule;
		nrulechain = pnrulechain;
	};

	Mfst::MfstDiagnosis::MfstDiagnosis() //конструктор
	{
		lenta_position = -1;
		rc_step = SURPRISE;
		nrule = -1;
		nrule_chain = -1;
	};

	Mfst::MfstDiagnosis::MfstDiagnosis(short plenta_position, RC_STEP prc_step, short pnrule, short pnrule_chain) //конструктор
	{
		lenta_position = plenta_position;
		rc_step = prc_step;
		nrule = pnrule;
		nrule_chain = pnrule_chain;
	};

	Mfst::Mfst() { lenta = 0; lenta_size = lenta_position = 0; }; //конструктор
	Mfst::Mfst(Lex::LEX plex, GRB::Greibach pgrebach) //конструктор
	{
		grebach = pgrebach;
		lex = plex;
		lenta = new short[lenta_size = lex.lextable.size];		// массив для ленты, состоящией из символов таблицы лексем
		for (int k = 0; k < lenta_size; k++)
			lenta[k] = TS(lex.lextable.table[k].lexema);	// заполнение массива терминалами
		lenta_position = 0;
		st.push(grebach.stbottomT);		// дно стека в стек
		st.push(grebach.startN);		// стартовый символ в стек
		nrulechain = -1;
	};

	Mfst::RC_STEP Mfst::step(const Log::LOG& log)		// шаг автомата
	{
		RC_STEP rc = SURPRISE;
		if (lenta_position < lenta_size)	// если лента не закончилась
		{
			if (ISNS(st.top()))			// если на вершине стеке нетерминал
			{
				GRB::Rule rule;
				if ((nrule = grebach.getRule(st.top(), rule)) >= 0)		// если найдено правило по нетерминалу на вершине стека... заполняем номер текущего правила
				{
					GRB::Rule::Chain chain;
					if ((nrulechain = rule.getNextChain(lenta[lenta_position], chain, nrulechain + 1)) >= 0)	// получаем следующую цепочку по терминалу из ленты и заполяем цепочку
					{
						MFST_TRACE1(log)			// вывод ++номера шага автомата, правила, ленты и стека
							savestate(log);		// сохраняем состояние
						st.pop();			// извлекаем из стека символ
						push_chain(chain);	// помещаем цепочку в стек
						rc = NS_OK;			// найдено правило и цепочка, цепочка записана в стек
						MFST_TRACE2(log)			// вывод номера шага автомата, ленты и стека
					}
					else		// не найдена подходящая цепочка
					{
						MFST_TRACE4(log, "TNS_NORULECHAIN/NS_NORULE")
							savediagnosis(NS_NORULECHAIN);
						rc = reststate(log) ? NS_NORULECHAIN : NS_NORULE;	// восстановить состояние автомата
					};
				}
				else rc = NS_ERROR;		// неизвестный нетерминал
			}
			else if ((st.top() == lenta[lenta_position]))	// если на вершине стека терминал и он совпадает 
			{
				lenta_position++;	// сдвигаем ленту
				st.pop();
				nrulechain = -1;
				rc = TS_OK;
				MFST_TRACE3(log)		// вывод ++номера шага автомата, ленты и стека
			}
			else
			{
				MFST_TRACE4(log, "TS_NOK/NS_NORULECHAIN")		// вывод ++номера шага автомата и сообщения
					rc = reststate(log) ? TS_NOK : NS_NORULECHAIN;
			};
		}
		else {
			rc = LENTA_END;
			MFST_TRACE4(log, "LENTA_END")
		};
		return rc;
	};

	bool Mfst::push_chain(GRB::Rule::Chain chain) //цепочка в стек с обратной стороны
	{
		for (int k = chain.size - 1; k >= 0; k--)
			st.push(chain.nt[k]);
		return true;
	};

	bool Mfst::savestate(const Log::LOG& log)
	{
		storestate.push(MfstState(lenta_position, st, nrule, nrulechain));
		MFST_TRACE6(log, "SAVESTATE:", storestate.size());		// вывод текста и размера стека для сохранения состояний
		return true;
	};

	bool Mfst::reststate(const Log::LOG& log) //восстановить состояние автомата
	{
		bool rc = false;
		MfstState state;
		if (rc = (storestate.size() > 0))
		{
			state = storestate.top();
			lenta_position = state.lenta_position;
			st = state.st;
			nrule = state.nrule;
			nrulechain = state.nrulechain;
			storestate.pop();
			MFST_TRACE5(log, "RESSTATE")
				MFST_TRACE2(log)
		};
		return rc;
	};

	bool Mfst::savediagnosis(RC_STEP prc_step)
	{
		bool rc = false;
		short k = 0;
		while (k < MFST_DIAGN_NUMBER && lenta_position <= diagnosis[k].lenta_position)
			k++;
		if (rc = (k < MFST_DIAGN_NUMBER))
		{
			diagnosis[k] = MfstDiagnosis(lenta_position, prc_step, nrule, nrulechain);
			for (short j = k + 1; j < MFST_DIAGN_NUMBER; j++)
				diagnosis[j].lenta_position = -1;
		};
		return rc;
	};

	bool Mfst::start(const Log::LOG& log)
	{
		bool rc = false;
		RC_STEP rc_step = SURPRISE;
		char buf[MFST_DIAGN_MAXSIZE];
		rc_step = step(log);
		while (rc_step == NS_OK || rc_step == NS_NORULECHAIN || rc_step == TS_OK || rc_step == TS_NOK)
			rc_step = step(log);

		switch (rc_step)
		{
		case LENTA_END:         MFST_TRACE4(log, "------>LENTA_END")
			* log.stream << "-------------------------------------------------------------------------------------" << std::endl;
			sprintf_s(buf, MFST_DIAGN_MAXSIZE, "%d:всего строк %d, синтаксический анализ выполнен без ошибок ", 0, lenta_size);
			*log.stream << std::setw(4) << std::left << 0 << ":всего строк " << lenta_size << ", синтаксический анализ выполнен без ошибок " << std::endl;
			rc = true;
			break;
		case NS_NORULE:         MFST_TRACE4(log, "------>NS_NORULE")
			* log.stream << "-------------------------------------------------------------------------------------" << std::endl;
			*log.stream << getDiagnosis(0, buf) << std::endl;
			*log.stream << getDiagnosis(1, buf) << std::endl;
			*log.stream << getDiagnosis(2, buf) << std::endl;
			break;
		case NS_NORULECHAIN:       MFST_TRACE4(log, "------>NS_NORULECHAIN") break;
		case NS_ERROR:             MFST_TRACE4(log, "------>NS_ERROR") break;
		case SURPRISE:             MFST_TRACE4(log, "------>SURPRISE") break;
		};
		return rc;
	};

	char* Mfst::getCSt(char* buf) //вывод стека
	{
		for (int k = (signed)st.size() - 1; k >= 0; --k)
		{
			short p = st._Get_container()[k];
			buf[st.size() - 1 - k] = GRB::Rule::Chain::alphabet_to_char(p);
		};
		buf[st.size()] = 0x00;
		return buf;
	};

	char* Mfst::getCLenta(char* buf, short pos, short n) //вывод ленты 
	{
		short i, k = (pos + n < lenta_size) ? pos + n : lenta_size;
		for (i = pos; i < k; i++)
			buf[i - pos] = GRB::Rule::Chain::alphabet_to_char(lenta[i]);
		buf[i - pos] = 0x00;
		return buf;
	};

	const char* Mfst::getDiagnosis(short n, char* buf) //вывод диагностики - ИСПРАВЛЕНО: возвращаемый тип const char*
	{
		const char* rc = ""; // ИСПРАВЛЕНО: тип const char*
		int errid = 0;
		int lpos = -1;
		if (n < MFST_DIAGN_NUMBER && (lpos = diagnosis[n].lenta_position) >= 0)
		{
			errid = grebach.getRule(diagnosis[n].nrule).iderror;
			Error::ERROR err = Error::geterror(errid);
			sprintf_s(buf, MFST_DIAGN_MAXSIZE, "%d: строка %d, %s", err.id, lex.lextable.table[lpos].sn, err.message);
			rc = buf;
		};
		return rc;
	};

	void Mfst::printrules(const Log::LOG& log)//вывод правил
	{
		MfstState state;
		GRB::Rule rule;
		for (unsigned short k = 0; k < storestate.size(); k++)
		{
			state = storestate._Get_container()[k];
			rule = grebach.getRule(state.nrule);
			MFST_TRACE7(log)
		};
	};

	bool Mfst::savededucation()
	{
		MfstState state;
		GRB::Rule rule;
		size_t storestate_size = storestate.size();
		deducation.size = (storestate_size <= SHRT_MAX) ? static_cast<short>(storestate_size) : SHRT_MAX;
		deducation.nrules = new short[deducation.size];
		deducation.nrulechains = new short[deducation.size];
		for (unsigned short k = 0; k < storestate.size() && k < static_cast<unsigned short>(deducation.size); k++)
		{
			state = storestate._Get_container()[k];
			deducation.nrules[k] = state.nrule;
			deducation.nrulechains[k] = state.nrulechain;
		};
		return true;
	};
}

file Parm.cpp:
#include "pch.h"
namespace Parm
{
	PARM getparm(int argc, _TCHAR* argv[])
	{
		PARM Input = {}; //создание экземпляра структуры для хранения информации

		for (int i = 1; i < argc; i++)
		{
			if (wcslen(argv[i]) > PARM_MAX_SIZE) //если длина параметра больше максимальной
			{
				throw ERROR_THROW(104)
			}
			if (wcsstr(argv[i], PARM_IN)) // wcsstr(arcg, PARM_IN) проверяет на наличие строки  PARM_IN в строке arcg возвращает NULL если строку не находит
				wcscpy_s(Input.in, argv[i] + wcslen(PARM_IN));  //Копируем в Input.in , путь к нашему файлу (содержимое argv , начиная с wcslen(PARM_IN)( длины строки PARM_IN))
			else if (wcsstr(argv[i], PARM_OUT))
				wcscpy_s(Input.out, argv[i] + wcslen(PARM_OUT));
			else if (wcsstr(argv[i], PARM_LOG))
				wcscpy_s(Input.log, argv[i] + wcslen(PARM_LOG));
		}
		if (wcslen(Input.in) == 0) //если параметр -in: не задан
			throw ERROR_THROW(100);
		if (wcslen(Input.out) == 0)
		{
			wcscpy_s(Input.out, Input.in);//копирование в строку Input.out строки Input.in
			wcsncat_s(Input.out, PARM_OUT_DEFAULT_EXT, wcslen(PARM_OUT_DEFAULT_EXT)); // добавление wcslen(PARM_OUT_DEFAULT_EXT) символов строки PARM_OUT_DEFAULT_EXT в Input.out
		}
		if (wcslen(Input.log) == 0)
		{
			wcscpy_s(Input.log, Input.in);//копирование в строку Input.out строки Input.in
			wcsncat_s(Input.log, PARM_LOG_DEFAULT_EXT, wcslen(PARM_LOG_DEFAULT_EXT)); // добавление wcslen(PARM_OUT_DEFAULT_EXT) символов строки PARM_OUT_DEFAULT_EXT в Input.out
		}
		return Input;
	}
}

file pch.cpp:
// pch.cpp: исходный файл, соответствующий предкомпилированному заголовку; нужен для компиляции

#include "pch.h"

// В целом этот файл можно пропустить, но не удаляйте его, если вы используете предкомпилированные заголовки.

file PolishNotation.cpp:
#include "pch.h"
using namespace std;

namespace Polish
{
	int getPriority(unsigned char e)
	{
		switch (e)
		{
		case LEX_LEFTHESIS: case LEX_RIGHTTHESIS: return 0;
		case LEX_COMMA: return 1;
		case LEX_PLUS: case LEX_MINUS: return 2;
		case LEX_STAR: case LEX_DIRSLASH: case LEX_PROCENT: return 3;
		default: return -1;
		}
	}
	int searchExpression(Lex::LEX lex) {
		bool fl = false;
		Lex::LEX result;
		result.lextable = LT::Create(lex.lextable.size);
		result.idtable = IT::Create(lex.idtable.size);
		for (int i = 0,k =0; i < lex.lextable.size; i++) 
		{
			if (lex.lextable.table[i].lexema == LEX_EQUAL) {
				lex.lextable.size = PolishNotation(++i, lex);
			}
		}
		return lex.lextable.size;
	}
	int PolishNotation(int lextable_pos, Lex::LEX& lex)
	{
		stack<LT::Entry> stack;														// стек для операций
		queue<LT::Entry> queue;														// очередь для операндов
		LT::Entry temp;		temp.idxTI = -1;	temp.lexema = '#';	temp.sn = -1;	// запрещенная лексема, все лишние элементы будут заменяться на нее
		LT::Entry func;		func.idxTI = -1;	func.lexema = '@';	func.sn = -1;	// лексема для вызова функции
		LT::Entry tilda;	tilda.idxTI = -1;	tilda.lexema = '~';	tilda.sn = -1;	// лексема для отрицательных
		int countLex = 0;															// количество преобразованных лексем
		int countParm = -1;															// количество параметров функции
		int posLex = lextable_pos;													// запоминаем номер лексемы перед преобразованием
		bool findFunc = false;														// флаг для функции
		bool findComma = false;														// флаг для запятой (кол-во параметров +2 сразу)
		char* buf = new char[2];													// буфер для countParm в строковом представлении
		for (int i = lextable_pos; lex.lextable.table[i].lexema != LEX_SEPARATOR; i++, countLex++)
		{
			switch (lex.lextable.table[i].lexema)
			{
			case LEX_STDFUNC:
			case LEX_ID:															// если идентификатор
			{
				if (lex.idtable.table[lex.lextable.table[i].idxTI].idtype == IT::F || lex.idtable.table[lex.lextable.table[i].idxTI].idtype == IT::S)
				{
					findFunc = true;
				}
				if (findFunc)
				{
					countParm++;
				}
				queue.push(lex.lextable.table[i]);
				continue;
			}
			case LEX_LITERAL:															// если литерал
			{
				queue.push(lex.lextable.table[i]);	
				if (findFunc)
				{
					countParm++;
				}
				continue;
			}
			case LEX_LEFTHESIS:														// если (
			{
				stack.push(lex.lextable.table[i]);										// помещаем ее в стек
				continue;
			}
			case LEX_RIGHTTHESIS:														// если )
			{
				if (findFunc)															// если это вызов функции, то лексемы () заменяются на @ и кол-во параметров
				{
					func.sn = lex.lextable.table[i].sn;
					lex.lextable.table[i] = func;
					queue.push(lex.lextable.table[i]);									// добавляем в очередь лексему вызова функции
					_itoa_s(countParm, buf, 2, 10);										// преобразование числа countParm в строку
					stack.top().lexema = buf[0];
					stack.top().idxTI = -1; stack.top().sn = lex.lextable.table[i].sn;						// заполняем лексему, указывающую количество параметров функции
					queue.push(stack.top());											// добавляем в очередь эту лексему
					findFunc = false;
				}
				else {
					while (stack.top().lexema != LEX_LEFTHESIS)						// пока не встретим (
					{
						queue.push(stack.top());										// выталкиваем со стека в очередь
						stack.pop();

						if (stack.empty())
							return 0;
					}
				}
				stack.pop();												// уничтожаем ( или лексему, указывающую количество параметров функции
				continue;
			}
			case LEX_PLUS:															// если знак оператора
			case LEX_MINUS:															// если знак оператора
			case LEX_STAR:															// если знак оператора
			case LEX_DIRSLASH:														// если знак оператора
			case LEX_PROCENT:														// если знак оператора
			{
				while (!stack.empty() && getPriority(lex.lextable.table[i].lexema) <= getPriority(stack.top().lexema))	// пока приоритет текущего оператора 
																							//меньше или равен приоритету оператора в вершине стека
				{
					queue.push(stack.top());											// выталкиваем со стека в выходную строку
					stack.pop();
				}
				stack.push(lex.lextable.table[i]);
				continue;
			}
			case LEX_COMMA:																// если запятая
			{
				findComma = true;
				continue;
			}
			}
		}
		while (!stack.empty())															// если стек не пустой
		{
			if (stack.top().lexema == LEX_LEFTHESIS || stack.top().lexema == LEX_RIGHTTHESIS)
				return 0;
			queue.push(stack.top());													// выталкиваем все в очередь
			stack.pop();
		}
		// Вывод ПОЛИЗ в консоль: разбиваем по строкам исходного кода
		// (чтобы не было одной длинной строки для всех выражений)
		static int lastPrintedLine = -1;

		while (countLex != 0)															// замена текущего выражения в таблице лексем на польскую запись
		{
			if (!queue.empty()) {
				lex.lextable.table[posLex++] = queue.front();

				// Красивый отладочный вывод: одна строка ПОЛИЗ на одну строку исходника
				int curLine = lex.lextable.table[posLex - 1].sn;
				if (lastPrintedLine == -1 || curLine != lastPrintedLine)
				{
					// Переход на новую строку перед выводом ПОЛИЗ для следующей строки исходника
					if (lastPrintedLine != -1)
						cout << endl;

					cout << setw(5) << curLine << " | ";
					lastPrintedLine = curLine;
				}

				cout << lex.lextable.table[posLex - 1].lexema << " ";				// вывод в консоль

				queue.pop();
			}
			else
			{
				lex.lextable.table[posLex++] = temp;
			}
			countLex--;
		}
		for (int i = 0; i < posLex; i++)												// восстановление индексов первого вхождения в таблицу лексем у операторов из таблицы идентификаторов
		{
			if (lex.lextable.table[i].lexema == LEX_LITERAL)
				lex.idtable.table[lex.lextable.table[i].idxTI].idxfirstLE = i;
		}
		return lex.lextable.size;
	}
}

file Semantic.cpp:
#include "pch.h"
#include "IT.h"
namespace Semantic
{
	// Вспомогательная функция для получения ожидаемого количества параметров стандартной функции
	int getExpectedParamsCount(const IT::Entry& e)
	{
		// Для стандартных функций всегда используем константы
		if (e.idtype == IT::IDTYPE::S)
		{
			// Для стандартных функций params.count уже установлен при создании в LexAnaliz.cpp
			// Но на всякий случай проверяем имя функции, если params.count == 0
			if (e.value.params.count > 0)
			{
				// Если количество параметров уже установлено, используем его
				return e.value.params.count;
			}
			
			// Если params.count == 0, проверяем имя функции (может быть с префиксом области видимости)
			// Используем strstr для поиска подстроки в имени функции
			if (strstr(e.id, "random") != nullptr || strstr(e.id, "_random") != nullptr)
				return RANDOM_PARAMS_CNT;
			if (strstr(e.id, "lenght") != nullptr || strstr(e.id, "_lenght") != nullptr)
				return LENGHT_PARAMS_CNT;
			if (strstr(e.id, "power") != nullptr || strstr(e.id, "pow") != nullptr || strstr(e.id, "_pow") != nullptr)
				return POW_PARAMS_CNT;
			if (strstr(e.id, "compare") != nullptr || strstr(e.id, "_compare") != nullptr)
				return COMPARE_PARAMS_CNT;
			
			// Если не найдено, возвращаем 0 (функция без параметров или неизвестная)
			return 0;
		}
		
		// Для обычных функций возвращаем установленное количество параметров
		return e.value.params.count;
	}
	
	// Вспомогательная функция для получения типа параметра стандартной функции по индексу
	IT::IDDATATYPE getExpectedParamType(const IT::Entry& e, int paramIndex)
	{
		if (e.idtype != IT::IDTYPE::S)
		{
			// Для обычных функций используем массив типов из записи
			if (paramIndex >= 0 && paramIndex < e.value.params.count)
				return e.value.params.types[paramIndex];
			return IT::IDDATATYPE::UNDEF;
		}
		
		// Для стандартных функций используем константы, если params.count == 0
		if (e.value.params.count == 0)
		{
			if (strcmp(e.id, "random") == 0 || strcmp(e.id, "_random") == 0)
			{
				if (paramIndex >= 0 && paramIndex < RANDOM_PARAMS_CNT)
					return IT::RANDOM_PARAMS[paramIndex];
			}
			if (strcmp(e.id, "lenght") == 0 || strcmp(e.id, "_lenght") == 0)
			{
				if (paramIndex >= 0 && paramIndex < LENGHT_PARAMS_CNT)
					return IT::LENGHT_PARAMS[paramIndex];
			}
			if (strcmp(e.id, "power") == 0 || strcmp(e.id, "pow") == 0 || strcmp(e.id, "_pow") == 0)
			{
				if (paramIndex >= 0 && paramIndex < POW_PARAMS_CNT)
					return IT::POW_PARAMS[paramIndex];
			}
			if (strcmp(e.id, "compare") == 0 || strcmp(e.id, "_compare") == 0)
			{
				if (paramIndex >= 0 && paramIndex < COMPARE_PARAMS_CNT)
					return IT::COMPARE_PARAMS[paramIndex];
			}
		}
		else
		{
			// Используем массив типов из записи
			if (paramIndex >= 0 && paramIndex < e.value.params.count)
				return e.value.params.types[paramIndex];
		}
		return IT::IDDATATYPE::UNDEF;
	}
	bool Semantic::semanticsCheck(Lex::LEX & tables, Log::LOG & log)
	{
		bool sem_ok = true;

		for (int i = 0; i < tables.lextable.size; i++)
		{
			switch (tables.lextable.table[i].lexema)
			{
				//В объявлении не указан тип идентификатора
			case LEX_TYPE:
			{
				// Проверяем, что после type идет тип данных (integer, string, symbol)
				if (i + 1 >= tables.lextable.size || tables.lextable.table[i + 1].lexema != LEX_ID_TYPE)
				{
					sem_ok = false;
					Log::WriteError(log.stream, Error::geterrorin(303, tables.lextable.table[i].sn, tables.lextable.table[i].col));
				}
				// Проверяем, что после типа данных идет идентификатор, а не сразу ;
				else if (i + 2 < tables.lextable.size)
				{
					char nextLex = tables.lextable.table[i + 2].lexema;
					// type integer; - отсутствует имя идентификатора
					if (nextLex == LEX_SEPARATOR || nextLex == LEX_BRACELET)
					{
						sem_ok = false;
						Log::WriteError(log.stream, Error::geterrorin(303, tables.lextable.table[i + 1].sn, tables.lextable.table[i + 1].col));
					}
				}
				// Если после типа данных ничего нет (конец таблицы), это тоже ошибка
				else if (i + 2 >= tables.lextable.size)
				{
					sem_ok = false;
					Log::WriteError(log.stream, Error::geterrorin(303, tables.lextable.table[i + 1].sn, 0));
				}
				break;
			}
			//ипы данных в выражении не совпадают
			case LEX_INCR:
			{
				IT::Entry e = tables.idtable.table[tables.lextable.table[i-1].idxTI];
				if (e.iddatatype != IT::IDDATATYPE::INT || tables.idtable.table[tables.lextable.table[i + 1].idxTI].iddatatype != IT::IDDATATYPE::INT)
				{
					sem_ok = false;
						Log::WriteError(log.stream, Error::geterrorin(314, tables.lextable.table[i].sn, tables.lextable.table[i].col));
				}
				if (tables.idtable.table[tables.lextable.table[i].idxTI].id[1] != LEX_DIRSLASH)
					break;

			}
			//Деление на ноль
			case LEX_DIRSLASH:
			case LEX_PROCENT:
			{
				int k = i;
				if (tables.lextable.table[i + 1].lexema == LEX_ID)
				{
					for (k; k > 0; k--)
					{
						if (tables.lextable.table[k].lexema == LEX_ID)
						{
							if (tables.idtable.table[tables.lextable.table[k].idxTI].id == tables.idtable.table[tables.lextable.table[i + 1].idxTI].id)
							{
								if (tables.lextable.table[k + 2].lexema == LEX_LITERAL && tables.idtable.table[tables.lextable.table[k + 2].idxTI].value.vint == 0)
								{
									sem_ok = false;
									Log::WriteError(log.stream, Error::geterrorin(317, tables.lextable.table[i].sn, tables.lextable.table[i].col));
								}
							}
						}
					}
				}
				if (tables.lextable.table[i + 1].lexema == LEX_LITERAL)
				{
					if (tables.idtable.table[tables.lextable.table[i + 1].idxTI].value.vint == 0)
					{
						sem_ok = false;
						Log::WriteError(log.stream, Error::geterrorin(317, tables.lextable.table[k].sn, tables.lextable.table[k].col));
					}
				}
				break;
			}
			case LEX_EQUAL: // выражение
			{
				if (i > 0 && tables.lextable.table[i - 1].idxTI != TI_NULLIDX) // левый операнд
				{
					IT::IDDATATYPE lefttype = tables.idtable.table[tables.lextable.table[i - 1].idxTI].iddatatype;
					int leftIdx = tables.lextable.table[i - 1].idxTI;
					bool ignore = false;
					bool isSimpleAssignment = false; // флаг для простого присваивания (x = literal)
					int rightLiteralIdx = TI_NULLIDX; // индекс литерала справа от =

					// Проверяем, является ли правая часть простым литералом (не выражением)
					if (i + 1 < tables.lextable.size && 
						tables.lextable.table[i + 1].lexema == LEX_LITERAL && 
						tables.lextable.table[i + 1].idxTI != TI_NULLIDX)
					{
						// Проверяем, что после литерала сразу идет разделитель (простое присваивание)
						if (i + 2 < tables.lextable.size && 
							tables.lextable.table[i + 2].lexema == LEX_SEPARATOR)
						{
							isSimpleAssignment = true;
							rightLiteralIdx = tables.lextable.table[i + 1].idxTI;
						}
					}

					for (int k = i + 1; tables.lextable.table[k].lexema != LEX_SEPARATOR; k++)
					{
						if (k == tables.lextable.size)
							break; // синтакс ошибка - нет ;
						if (tables.lextable.table[k].idxTI != TI_NULLIDX) // если ид - проверить совпадение типов
						{
							if (!ignore)
							{
								IT::IDDATATYPE righttype = tables.idtable.table[tables.lextable.table[k].idxTI].iddatatype;
								if (lefttype != righttype) // типы данных в выражении не совпадают
								{
									Log::WriteError(log.stream, Error::geterrorin(314, tables.lextable.table[k].sn, tables.lextable.table[k].col));
									sem_ok = false;
									break;
								}
							}
							// если лексема сразу после идентиф скобка - это вызов функции
							if (tables.lextable.table[k + 1].lexema == LEX_LEFTHESIS)
							{
								ignore = true;
								continue;
							}
							// закрывающая скобка после списка параметров
							if (ignore && tables.lextable.table[k + 1].lexema == LEX_RIGHTTHESIS)
							{
								ignore = false;
								continue;
							}
						}
						if (lefttype == IT::IDDATATYPE::STR || lefttype == IT::IDDATATYPE::SYM) // справа только литерал, ид или вызов строковой ф-ции
						{
							char l = tables.lextable.table[k].lexema;
							if (l == LEX_PLUS || l == LEX_MINUS || l == LEX_STAR || l == LEX_DIRSLASH || l == LEX_PROCENT) // выражения недопустимы
							{
								Log::WriteError(log.stream, Error::geterrorin(315, tables.lextable.table[k].sn, tables.lextable.table[k].col));
								sem_ok = false;
								break;
							}
						}
					}

					// Устанавливаем значение переменной, если это простое присваивание (x = literal)
					if (isSimpleAssignment && rightLiteralIdx != TI_NULLIDX && 
						tables.idtable.table[leftIdx].idtype == IT::IDTYPE::V)
					{
						IT::Entry& leftEntry = tables.idtable.table[leftIdx];
						IT::Entry& rightEntry = tables.idtable.table[rightLiteralIdx];
						
						if (leftEntry.iddatatype == IT::IDDATATYPE::INT && 
							rightEntry.iddatatype == IT::IDDATATYPE::INT &&
							rightEntry.idtype == IT::IDTYPE::L)
						{
							// Копируем значение из литерала в переменную
							leftEntry.value.vint = rightEntry.value.vint;
						}
						else 						if (leftEntry.iddatatype == IT::IDDATATYPE::STR &&
								 rightEntry.iddatatype == IT::IDDATATYPE::STR &&
								 rightEntry.idtype == IT::IDTYPE::L)
						{
							// Копируем строку из литерала в переменную
							// Проверяем размер перед копированием, чтобы избежать предупреждения strcpy_s
							size_t src_len = strlen(rightEntry.value.vstr.str);
							size_t max_str_size = STR_MAXSIZE - 1; // Размер буфера vstr.str
							size_t max_copy_len = max_str_size - 1; // Максимальная длина для копирования (с учетом '\0')
							if (src_len > max_copy_len)
							{
								// Строка слишком длинная, обрезаем до максимального размера
								src_len = max_copy_len;
							}
							leftEntry.value.vstr.len = (int)src_len;
							// Используем memcpy для избежания проблем с strncpy_s
							if (src_len > 0)
							{
								memcpy(leftEntry.value.vstr.str, rightEntry.value.vstr.str, src_len);
							}
							leftEntry.value.vstr.str[src_len] = '\0';
						}
						else if (leftEntry.iddatatype == IT::IDDATATYPE::SYM && 
								 rightEntry.iddatatype == IT::IDDATATYPE::SYM &&
								 rightEntry.idtype == IT::IDTYPE::L)
						{
							// Копируем символ из литерала в переменную
							leftEntry.value.symbol = rightEntry.value.symbol;
						}
					}
				}
				break;
			}
			case LEX_ID: // проверка типа возвращаемого значения  
			case LEX_STDFUNC: // стандартные функции
			{
				IT::Entry e = tables.idtable.table[tables.lextable.table[i].idxTI];
				if (i > 0 && tables.lextable.table[i - 1].lexema == LEX_FUNCTION)
				{
					if (e.idtype == IT::IDTYPE::F ) //функция
					{
						for (int k = i + 1; tables.lextable.table[k].lexema != LEX_BRACELET; k++)
						{
							char l = tables.lextable.table[k].lexema;
							if (l == LEX_RETURN)
							{
								int next = tables.lextable.table[k + 1].idxTI; // след. за return
								if (next != TI_NULLIDX )
								{
									if (tables.idtable.table[next].iddatatype != e.iddatatype)			// тип функции и возвращаемого значения не совпадают
									{
										Log::WriteError(log.stream, Error::geterrorin(314, tables.lextable.table[k].sn, tables.lextable.table[k].col));
										sem_ok = false;
										break;
									}
								}
								if (next != TI_NULLIDX && e.iddatatype == IT::IDDATATYPE::PROC|| next == TI_NULLIDX && e.iddatatype != IT::IDDATATYPE::PROC)
								{
									Log::WriteError(log.stream, Error::geterrorin(314, tables.lextable.table[k].sn, tables.lextable.table[k].col));
									sem_ok = false;
									break;
								}
							}

							if (k == tables.lextable.size)
								break;
						}
					}
				}
				if (i + 1 < tables.lextable.size && tables.lextable.table[i + 1].lexema == LEX_LEFTHESIS && (i == 0 || tables.lextable.table[i - 1].lexema != LEX_FUNCTION)) // именно вызов
				{
					if (e.idtype == IT::IDTYPE::F || e.idtype == IT::IDTYPE::S) // точно функция
					{
						int paramscount = 0; // Инициализируем 0 вместо NULL
						// проверка передаваемых параметров
						for (int j = i + 1; tables.lextable.table[j].lexema != LEX_RIGHTTHESIS; j++)
						{
							// проверка соответствия передаваемых параметров прототипам
							if (tables.lextable.table[j].lexema == LEX_ID || tables.lextable.table[j].lexema == LEX_LITERAL)
							{
								paramscount++;
								// Проверка превышения максимального количества параметров ДО проверки типов
								if (paramscount > MAX_PARAMS_COUNT)
								{
									// Превышено максимальное количество параметров функции
									Log::WriteError(log.stream, Error::geterrorin(306, tables.lextable.table[i].sn, tables.lextable.table[i].col));
									sem_ok = false;
									break;
								}
								// Получаем ожидаемое количество параметров и тип текущего параметра
								int expectedParams = getExpectedParamsCount(e);
								IT::IDDATATYPE expectedType = getExpectedParamType(e, paramscount - 1);
								
								// Проверка типов параметров только если функция имеет определенные параметры
								if (expectedParams > 0 && expectedType != IT::IDDATATYPE::UNDEF)
								{
									IT::IDDATATYPE ctype = tables.idtable.table[tables.lextable.table[j].idxTI].iddatatype;
									if (paramscount <= expectedParams && ctype != expectedType)
									{
										// Несовпадение типов передаваемых параметров
										Log::WriteError(log.stream, Error::geterrorin(309, tables.lextable.table[i].sn, tables.lextable.table[i].col));
										sem_ok = false;
										break;
									}
								}
							}
							if (j == tables.lextable.size)
								break;
						}
						// Получаем ожидаемое количество параметров (используем константы для стандартных функций)
						int expectedParams = getExpectedParamsCount(e);
						
						// Проверка превышения максимального количества параметров (MAX_PARAMS_COUNT)
						if (paramscount > MAX_PARAMS_COUNT)
						{
							// Превышено максимальное количество параметров функции
							Log::WriteError(log.stream, Error::geterrorin(306, tables.lextable.table[i].sn, tables.lextable.table[i].col));
							sem_ok = false;
						}
						// Проверка, что количество параметров при вызове превышает ожидаемое (ошибка 306)
						else if (expectedParams > 0 && paramscount > expectedParams)
						{
							// Превышено максимальное количество параметров функции (больше, чем ожидает функция)
							Log::WriteError(log.stream, Error::geterrorin(306, tables.lextable.table[i].sn, tables.lextable.table[i].col));
							sem_ok = false;
						}
					}
				}
				break;
			}
			case LEX_MORE:	case LEX_LESS: 
			{
				// левый и правый операнд - числовой тип
				bool flag = true;
				if (i > 1 && tables.lextable.table[i - 1].idxTI != TI_NULLIDX)
				{
					if (tables.idtable.table[tables.lextable.table[i - 1].idxTI].iddatatype != IT::IDDATATYPE::INT)
						flag = false;
				}
				if (tables.lextable.table[i + 1].idxTI != TI_NULLIDX)
				{
					if (tables.idtable.table[tables.lextable.table[i + 1].idxTI].iddatatype != IT::IDDATATYPE::INT)
						flag = false;
				}
				if (!flag)
				{
					// Неверное условное выражение (не числовой тип)
					Log::WriteError(log.stream, Error::geterrorin(317, tables.lextable.table[i].sn, tables.lextable.table[i].col));
					sem_ok = false;
				}
				break;
			}
			case LEX_EQUALS:   case LEX_NOTEQUALS:
			{
				bool flag = false;
				if (i > 1 && tables.lextable.table[i - 1].idxTI != TI_NULLIDX)
				{
					if (tables.idtable.table[tables.lextable.table[i - 1].idxTI].iddatatype == IT::IDDATATYPE::INT
						&& tables.idtable.table[tables.lextable.table[i + 1].idxTI].iddatatype == IT::IDDATATYPE::INT)
						flag = true;
					else if (tables.idtable.table[tables.lextable.table[i - 1].idxTI].iddatatype == IT::IDDATATYPE::SYM
						&& tables.idtable.table[tables.lextable.table[i + 1].idxTI].iddatatype == IT::IDDATATYPE::SYM)
						flag = true;
					else if (tables.idtable.table[tables.lextable.table[i - 1].idxTI].iddatatype == IT::IDDATATYPE::STR
						&& tables.idtable.table[tables.lextable.table[i + 1].idxTI].iddatatype == IT::IDDATATYPE::STR)
						flag = true;
				}
				if (!flag)
				{
					// Неверное условное выражение
					Log::WriteError(log.stream, Error::geterrorin(317, tables.lextable.table[i].sn, tables.lextable.table[i].col));
					sem_ok = false;
				}
				break;
			}
			}
		}
		return sem_ok;
	}
};

file Error.h:
#pragma once
#define ERROR_THROW(id) Error::geterror(id);
#define ERROR_THROW_IN(id,l,c) Error::geterrorin(id,l,c);
#define ERROR_ENTRY(id, m) {id,m,{-1,-1}}        //Элемент таблицы ошибок
#define ERROR_MAXSIZE_MESSAGE 200                //максимальная длина сообщения об ошибке
#define ERROR_ENTRY_NODEF(id) ERROR_ENTRY(-id,"Неопределенная ошибка") // 1 неопределенный элемент таблицы ошибок
// ERROR_ENTRY_NODEF10(id) - 10 неопределенных элементов таблицы ошибок
#define ERROR_ENTRY_NODEF10(id) ERROR_ENTRY_NODEF(id+0),ERROR_ENTRY_NODEF(id+1),ERROR_ENTRY_NODEF(id+2),ERROR_ENTRY_NODEF(id+3),\
								ERROR_ENTRY_NODEF(id+4),ERROR_ENTRY_NODEF(id+5),ERROR_ENTRY_NODEF(id+6),ERROR_ENTRY_NODEF(id+7),\
								ERROR_ENTRY_NODEF(id+8),ERROR_ENTRY_NODEF(id+9)
// ERROR_ENTRY_NODEF10(id) - 100 неопределенных элементов таблицы ошибок
#define ERROR_ENTRY_NODEF100(id) ERROR_ENTRY_NODEF10(id+0),ERROR_ENTRY_NODEF10(id+10),ERROR_ENTRY_NODEF10(id+20),ERROR_ENTRY_NODEF10(id+30),\
								ERROR_ENTRY_NODEF10(id+40),ERROR_ENTRY_NODEF10(id+50),ERROR_ENTRY_NODEF10(id+60),ERROR_ENTRY_NODEF10(id+70),\
								ERROR_ENTRY_NODEF10(id+80),ERROR_ENTRY_NODEF10(id+90)
#define ERROR_MAX_ENTRY 1000       //количество элементов в таблице ошибок

namespace Error
{
	struct ERROR      //тип исключения
	{
		int id;         //код ошибки
		char message[ERROR_MAXSIZE_MESSAGE];    //сообщение об ошибке
		struct IN           // расширение для ошибок при обработке входных данных
		{
			short line;      //Номер строки
			short col;		//номер позиции в сроке
		}position;
	};

	ERROR geterror(int id);       // сформирование ERROR для ERROR_THROW
	ERROR geterrorin(int id, int line, int col);// сформирование ERROR для ERROR_THROW_IN
};

file FST.h:
#pragma once
#include "pch.h"
namespace FST
{
	struct RELATION					//ребро:символ -> вершина графа переходов КА
	{
		unsigned char symbol;				//симпол перехода	
		short nnode;				//номер смежной вершины
		RELATION(
			unsigned char c = 0x00,	//символ перехода
			short ns = 0			//номер смежной вершины
		);
	};

	struct NODE						//вершина графа переходов
	{
		short n_relation;			//количество инцидентных ребер
		RELATION *relations;		//инцидентные ребра
		NODE();
		NODE
		(short n,				//количество инцидентных ребер
			RELATION rel, ...		//список ребер
		);
	};

	struct FST						//недетерминированный конечный автомат
	{
		unsigned char* string;				//цепочка (строка,завершается 0х00)
		short position;				//текущая позиция в цепочке
		short nstates;				//количество состояний автомата
		NODE* nodes;				//граф переходов: [0] - начальное состояние, [nstate-1] - конечное
		short* rstates;				//возможные состояния автомата на данной позиции
		FST(short ns, NODE n, ...);
		FST(unsigned char* s, FST& fst);
		FST(
			unsigned char* s,		//цепочка (строка, завершаеся 0х00)
			short ns,				//количество состояний автомата
			NODE n, ...				//список состояний (граф переходов)
		);
	};
	bool execute(
		FST& fst
	);


}

file Generator.h:
#pragma once
#include "pch.h"
#define SEPSTREMP  "\n;------------------------------\n"
#define SEPSTR(x)  "\n;----------- " + string(x) + " ------------\n"


#define BEGIN ".586\n"\
".model flat, stdcall\n"\
"OPTION CASEMAP:NONE\n"\
"includelib libucrt.lib\n"\
"includelib kernel32.lib\n"\
"includelib ENV2025Lib.lib\n"\
"ExitProcess PROTO :DWORD \n"\
".stack 65536\n"

#define END "call system_pause"\
				"\npush 0"\
				"\ncall ExitProcess"\
				"\nSOMETHINGWRONG:"\
				"\npush offset null_division"\
				"\ncall outstrline\n"\
				"call system_pause"\
				"\npush -1"\
				"\ncall ExitProcess"\
				"\nEXIT_OVERFLOW:"\
				"\npush offset overflow"\
				"\ncall outstrline\n"\
				"call system_pause"\
				"\npush -2"\
				"\ncall ExitProcess"\
				"\nmain ENDP\n"\
				"end main\n"


#define EXTERN "\n outnum PROTO : DWORD\n"\
"\n outstr PROTO : DWORD\n"\
"\n outstrline PROTO : DWORD\n"\
"\n outnumline PROTO : DWORD\n"\
"\n system_pause PROTO\n"\
"\n random PROTO : DWORD, : DWORD\n"\
"\n lenght PROTO : DWORD\n"\
"\n power PROTO : DWORD, : DWORD\n"\
"\n compare PROTO : DWORD, : DWORD\n"


#define ITENTRY(x)  lex.idtable.table[lex.lextable.table[x].idxTI]
#define LEXEMA(x)   lex.lextable.table[x].lexema


namespace Gener
{
	bool CodeGeneration(Lex::LEX& tables, Parm::PARM& parm, Log::LOG& log);
};

file Graphs.h:
#pragma once
#include "FST.h"
#define N_GRAPHS 30

// графы переходов 
#define GRAPH_SEPARATORS 2,\
	FST::NODE(19,\
			FST::RELATION(';',1), FST::RELATION('=',1),\
			FST::RELATION(',',1), FST::RELATION('{',1),\
			FST::RELATION('}',1), FST::RELATION('(',1),\
			FST::RELATION('[',1), FST::RELATION(']',1),\
			FST::RELATION(')',1), FST::RELATION('*',1),\
			FST::RELATION('+',1), FST::RELATION('-',1),\
		    FST::RELATION('/',1),FST::RELATION('<',1),\
			FST::RELATION('>',1),\
			FST::RELATION('&',1),\
			FST::RELATION('!',1), FST::RELATION('%',1),\
			FST::RELATION('@',1)),\
	FST::NODE()
#define GRAPH_INKR 3,\
	FST::NODE(1,FST::RELATION(':',1)),\
	FST::NODE(4,FST::RELATION('+',2),FST::RELATION('-',2),FST::RELATION('/',2),FST::RELATION('*',2)),\
	FST::NODE()

#define GRAPH_ID 3, \
	FST::NODE(106,	\
			FST::RELATION('a', 1), FST::RELATION('b', 1), FST::RELATION('c', 1), FST::RELATION('d', 1), FST::RELATION('e', 1), FST::RELATION('f', 1),\
			FST::RELATION('g', 1), FST::RELATION('h', 1), FST::RELATION('i', 1), FST::RELATION('j', 1), FST::RELATION('k', 1), FST::RELATION('l', 1),\
			FST::RELATION('m', 1), FST::RELATION('n', 1), FST::RELATION('o', 1), FST::RELATION('p', 1), FST::RELATION('q', 1), FST::RELATION('r', 1),\
			FST::RELATION('s', 1), FST::RELATION('t', 1), FST::RELATION('u', 1), FST::RELATION('v', 1), FST::RELATION('w', 1), FST::RELATION('x', 1),\
			FST::RELATION('y', 1), FST::RELATION('z', 1),\
			FST::RELATION('a', 2), FST::RELATION('b', 2), FST::RELATION('c', 2), FST::RELATION('d', 2), FST::RELATION('e', 2), FST::RELATION('f', 2),\
			FST::RELATION('g', 2), FST::RELATION('h', 2), FST::RELATION('i', 2), FST::RELATION('j', 2), FST::RELATION('k', 2), FST::RELATION('l', 2),\
			FST::RELATION('m', 2), FST::RELATION('n', 2), FST::RELATION('o', 2), FST::RELATION('p', 2), FST::RELATION('q', 2), FST::RELATION('r', 2),\
			FST::RELATION('s', 2), FST::RELATION('t', 2), FST::RELATION('u', 2), FST::RELATION('v', 2), FST::RELATION('w', 2), FST::RELATION('x', 2),\
			FST::RELATION('y', 2), FST::RELATION('z', 2),\
			FST::RELATION('A', 1), FST::RELATION('B', 1), FST::RELATION('C', 1), FST::RELATION('D', 1), FST::RELATION('E', 1), FST::RELATION('F', 1),\
			FST::RELATION('G', 1), FST::RELATION('H', 1), FST::RELATION('I', 1), FST::RELATION('J', 1), FST::RELATION('K', 1), FST::RELATION('L', 1),\
			FST::RELATION('M', 1), FST::RELATION('N', 1), FST::RELATION('O', 1), FST::RELATION('P', 1), FST::RELATION('Q', 1), FST::RELATION('R', 1),\
			FST::RELATION('S', 1), FST::RELATION('T', 1), FST::RELATION('U', 1), FST::RELATION('V', 1), FST::RELATION('W', 1), FST::RELATION('X', 1),\
			FST::RELATION('Y', 1), FST::RELATION('Z', 1),\
			FST::RELATION('A', 2), FST::RELATION('B', 2), FST::RELATION('C', 2), FST::RELATION('D', 2), FST::RELATION('E', 2), FST::RELATION('F', 2),\
			FST::RELATION('G', 2), FST::RELATION('H', 2), FST::RELATION('I', 2), FST::RELATION('J', 2), FST::RELATION('K', 2), FST::RELATION('L', 2),\
			FST::RELATION('M', 2), FST::RELATION('N', 2), FST::RELATION('O', 2), FST::RELATION('P', 2), FST::RELATION('Q', 2), FST::RELATION('R', 2),\
			FST::RELATION('S', 2), FST::RELATION('T', 2), FST::RELATION('U', 2), FST::RELATION('V', 2), FST::RELATION('W', 2), FST::RELATION('X', 2),\
			FST::RELATION('Y', 2), FST::RELATION('Z', 2),\
			FST::RELATION('_', 1), FST::RELATION('_', 2)),\
	FST::NODE(130,\
			FST::RELATION('a', 1), FST::RELATION('b', 1), FST::RELATION('c', 1), FST::RELATION('d', 1), FST::RELATION('e', 1), FST::RELATION('f', 1),\
			FST::RELATION('g', 1), FST::RELATION('h', 1), FST::RELATION('i', 1), FST::RELATION('j', 1), FST::RELATION('k', 1), FST::RELATION('l', 1),\
			FST::RELATION('m', 1), FST::RELATION('n', 1), FST::RELATION('o', 1), FST::RELATION('p', 1), FST::RELATION('q', 1), FST::RELATION('r', 1),\
			FST::RELATION('s', 1), FST::RELATION('t', 1), FST::RELATION('u', 1), FST::RELATION('v', 1), FST::RELATION('w', 1), FST::RELATION('x', 1),\
			FST::RELATION('y', 1), FST::RELATION('z', 1),\
			FST::RELATION('A', 1), FST::RELATION('B', 1), FST::RELATION('C', 1), FST::RELATION('D', 1), FST::RELATION('E', 1), FST::RELATION('F', 1),\
			FST::RELATION('G', 1), FST::RELATION('H', 1), FST::RELATION('I', 1), FST::RELATION('J', 1), FST::RELATION('K', 1), FST::RELATION('L', 1),\
			FST::RELATION('M', 1), FST::RELATION('N', 1), FST::RELATION('O', 1), FST::RELATION('P', 1), FST::RELATION('Q', 1), FST::RELATION('R', 1),\
			FST::RELATION('S', 1), FST::RELATION('T', 1), FST::RELATION('U', 1), FST::RELATION('V', 1), FST::RELATION('W', 1), FST::RELATION('X', 1),\
			FST::RELATION('Y', 1), FST::RELATION('Z', 1),\
			FST::RELATION('_', 1),\
			FST::RELATION('1', 1), FST::RELATION('2', 1), FST::RELATION('3', 1), FST::RELATION('4', 1), FST::RELATION('5', 1), FST::RELATION('6', 1),\
			FST::RELATION('7', 1), FST::RELATION('8', 1), FST::RELATION('9', 1), FST::RELATION('0', 1),\
			FST::RELATION('a', 2), FST::RELATION('b', 2), FST::RELATION('c', 2), FST::RELATION('d', 2), FST::RELATION('e', 2), FST::RELATION('f', 2),\
			FST::RELATION('g', 2), FST::RELATION('h', 2), FST::RELATION('i', 2), FST::RELATION('j', 2), FST::RELATION('k', 2), FST::RELATION('l', 2),\
			FST::RELATION('m', 2), FST::RELATION('n', 2), FST::RELATION('o', 2), FST::RELATION('p', 2), FST::RELATION('q', 2), FST::RELATION('r', 2),\
			FST::RELATION('s', 2), FST::RELATION('t', 2), FST::RELATION('u', 2), FST::RELATION('v', 2), FST::RELATION('w', 2), FST::RELATION('x', 2),\
			FST::RELATION('y', 2), FST::RELATION('z', 2),\
			FST::RELATION('A', 2), FST::RELATION('B', 2), FST::RELATION('C', 2), FST::RELATION('D', 2), FST::RELATION('E', 2), FST::RELATION('F', 2),\
			FST::RELATION('G', 2), FST::RELATION('H', 2), FST::RELATION('I', 2), FST::RELATION('J', 2), FST::RELATION('K', 2), FST::RELATION('L', 2),\
			FST::RELATION('M', 2), FST::RELATION('N', 2), FST::RELATION('O', 2), FST::RELATION('P', 2), FST::RELATION('Q', 2), FST::RELATION('R', 2),\
			FST::RELATION('S', 2), FST::RELATION('T', 2), FST::RELATION('U', 2), FST::RELATION('V', 2), FST::RELATION('W', 2), FST::RELATION('X', 2),\
			FST::RELATION('Y', 2), FST::RELATION('Z', 2),\
			FST::RELATION('_', 2),\
			FST::RELATION('1', 2), FST::RELATION('2', 2), FST::RELATION('3', 2), FST::RELATION('4', 2), FST::RELATION('5', 2), FST::RELATION('6', 2),\
			FST::RELATION('7', 2), FST::RELATION('8', 2), FST::RELATION('9', 2), FST::RELATION('0', 2)),\
	FST::NODE()


#define GRAPH_STRING_LITERAL 3,\
	FST::NODE(1, FST::RELATION('\"', 1)),\
	FST::NODE(90, \
			FST::RELATION('a', 1), FST::RELATION('b', 1), FST::RELATION('c', 1), FST::RELATION('d', 1),\
			FST::RELATION('e', 1), FST::RELATION('f', 1), FST::RELATION('g', 1), FST::RELATION('h', 1),\
			FST::RELATION('i', 1), FST::RELATION('j', 1), FST::RELATION('k', 1), FST::RELATION('l', 1),\
			FST::RELATION('m', 1), FST::RELATION('n', 1), FST::RELATION('o', 1), FST::RELATION('p', 1),\
			FST::RELATION('q', 1), FST::RELATION('r', 1), FST::RELATION('s', 1), FST::RELATION('t', 1),\
			FST::RELATION('u', 1), FST::RELATION('v', 1), FST::RELATION('w', 1), FST::RELATION('x', 1),\
			FST::RELATION('y', 1), FST::RELATION('z', 1),\
			FST::RELATION('A', 1), FST::RELATION('B', 1), FST::RELATION('C', 1), FST::RELATION('D', 1),\
			FST::RELATION('E', 1), FST::RELATION('F', 1), FST::RELATION('G', 1), FST::RELATION('H', 1),\
			FST::RELATION('I', 1), FST::RELATION('J', 1), FST::RELATION('K', 1), FST::RELATION('L', 1),\
			FST::RELATION('M', 1), FST::RELATION('N', 1), FST::RELATION('O', 1), FST::RELATION('P', 1),\
			FST::RELATION('Q', 1), FST::RELATION('R', 1), FST::RELATION('S', 1), FST::RELATION('T', 1),\
			FST::RELATION('U', 1), FST::RELATION('V', 1), FST::RELATION('W', 1), FST::RELATION('X', 1),\
			FST::RELATION('Y', 1), FST::RELATION('Z', 1),\
			FST::RELATION('0', 1), FST::RELATION('1', 1), FST::RELATION('2', 1), FST::RELATION('3', 1),\
			FST::RELATION('4', 1), FST::RELATION('5', 1), FST::RELATION('6', 1), FST::RELATION('7', 1),\
			FST::RELATION('8', 1), FST::RELATION('9', 1),\
			FST::RELATION(' ', 1), FST::RELATION(',', 1), FST::RELATION('.', 1), FST::RELATION(';', 1),\
			FST::RELATION('-', 1), FST::RELATION('+', 1), FST::RELATION('*', 1), FST::RELATION('/', 1),\
			FST::RELATION('%', 1), FST::RELATION('_', 1),\
			FST::RELATION('=', 1), FST::RELATION(':', 1), FST::RELATION(')', 1), FST::RELATION('(', 1),\
			FST::RELATION('}', 1), FST::RELATION('{', 1), FST::RELATION(']', 1), FST::RELATION('[', 1),\
			FST::RELATION('!', 1), FST::RELATION('?', 1), FST::RELATION('#', 1), FST::RELATION('&', 1),\
			FST::RELATION('>', 1), FST::RELATION('<', 1), FST::RELATION('[', 1), FST::RELATION(']', 1),\
			FST::RELATION('`', 1),\
			FST::RELATION('\"', 2)),\
	FST::NODE()
#define GRAPH_SYMBOL_LITERAL 4,\
	FST::NODE(1, FST::RELATION('~', 1)),\
	FST::NODE(88, \
			FST::RELATION('a', 2), FST::RELATION('b', 2), FST::RELATION('c', 2), FST::RELATION('d', 2),\
			FST::RELATION('e', 2), FST::RELATION('f', 2), FST::RELATION('g', 2), FST::RELATION('h', 2),\
			FST::RELATION('i', 2), FST::RELATION('j', 2), FST::RELATION('k', 2), FST::RELATION('l', 2),\
			FST::RELATION('m', 2), FST::RELATION('n', 2), FST::RELATION('o', 2), FST::RELATION('p', 2),\
			FST::RELATION('q', 2), FST::RELATION('r', 2), FST::RELATION('s', 2), FST::RELATION('t', 2),\
			FST::RELATION('u', 2), FST::RELATION('v', 2), FST::RELATION('w', 2), FST::RELATION('x', 2),\
			FST::RELATION('y', 2), FST::RELATION('z', 2),\
			FST::RELATION('A', 2), FST::RELATION('B', 2), FST::RELATION('C', 2), FST::RELATION('D', 2),\
			FST::RELATION('E', 2), FST::RELATION('F', 2), FST::RELATION('G', 2), FST::RELATION('H', 2),\
			FST::RELATION('I', 2), FST::RELATION('J', 2), FST::RELATION('K', 2), FST::RELATION('L', 2),\
			FST::RELATION('M', 2), FST::RELATION('N', 2), FST::RELATION('O', 2), FST::RELATION('P', 2),\
			FST::RELATION('Q', 2), FST::RELATION('R', 2), FST::RELATION('S', 2), FST::RELATION('T', 2),\
			FST::RELATION('U', 2), FST::RELATION('V', 2), FST::RELATION('W', 2), FST::RELATION('X', 2),\
			FST::RELATION('Y', 2), FST::RELATION('Z', 2),\
			FST::RELATION('0', 2), FST::RELATION('1', 2),FST::RELATION('2', 2), FST::RELATION('2', 2), FST::RELATION('3', 2),\
			FST::RELATION('4', 2), FST::RELATION('5', 2), FST::RELATION('6', 2), FST::RELATION('7', 2),\
			FST::RELATION('8', 2), FST::RELATION('9', 2),\
			FST::RELATION(' ', 2), FST::RELATION(',', 2), FST::RELATION('.', 2), FST::RELATION(';', 2),\
			FST::RELATION('-', 2), FST::RELATION('+', 2), FST::RELATION('*', 2), FST::RELATION('/', 2),\
			FST::RELATION('=', 2), FST::RELATION(':', 2), FST::RELATION(')', 2), FST::RELATION('(', 2),\
			FST::RELATION('}', 2), FST::RELATION('{', 2), FST::RELATION(']', 2), FST::RELATION('[', 2),\
			FST::RELATION('!', 2), FST::RELATION('?', 2), FST::RELATION('#', 2), FST::RELATION('&', 2),\
			FST::RELATION('>', 2), FST::RELATION('<', 2), FST::RELATION('[', 2), FST::RELATION(']', 2)),\
	FST::NODE(1, FST::RELATION('~', 3)), \
	FST::NODE()
#define GRAPH_INT_NEGATIVE 7,\
	FST::NODE(1, \
			FST::RELATION('-', 1)),\
	FST::NODE(3, \
			FST::RELATION('0', 2),FST::RELATION('0', 4),FST::RELATION('0', 6)),\
	FST::NODE(1, \
			FST::RELATION('x', 3)),\
	FST::NODE(32,\
			FST::RELATION('1',3),FST::RELATION('0',3),		FST::RELATION('2',3),FST::RELATION('3',3),\
			FST::RELATION('A',3),FST::RELATION('B',3),		FST::RELATION('4',3),FST::RELATION('5',3),\
			FST::RELATION('C',3),FST::RELATION('D',3),		FST::RELATION('6',3),FST::RELATION('7',3),\
			FST::RELATION('E',3),FST::RELATION('F',3),		FST::RELATION('8',3),FST::RELATION('9',3),\
			FST::RELATION('1',5),FST::RELATION('0',5),		FST::RELATION('2',5),FST::RELATION('3',5),\
			FST::RELATION('A',5),FST::RELATION('B',5),		FST::RELATION('4',5),FST::RELATION('5',5),\
			FST::RELATION('C',5),FST::RELATION('D',5),		FST::RELATION('6',5),FST::RELATION('7',5),\
			FST::RELATION('E',5),FST::RELATION('F',5),		FST::RELATION('8',5),FST::RELATION('9',5)),\
	FST::NODE(16,\
			FST::RELATION('1',4),FST::RELATION('0',4),		FST::RELATION('2',2),FST::RELATION('3',4),\
			FST::RELATION('4',4),FST::RELATION('5',4),		FST::RELATION('6',2),FST::RELATION('7',4),\
			FST::RELATION('1',5),FST::RELATION('0',5),		FST::RELATION('2',5),FST::RELATION('3',5),\
			FST::RELATION('4',5),FST::RELATION('5',5),		FST::RELATION('6',5),FST::RELATION('7',5)),\
	FST::NODE(1, FST::RELATION('b', 7)),\
	FST::NODE(2,\
			FST::RELATION('0',7),FST::RELATION('1',7)),\
	FST::NODE()

#define GRAPH_INT_LITERAL 2,\
	/* Состояние 0: начало числа, допускает необязательный '-' и первую цифру */\
	FST::NODE(11,\
			FST::RELATION('-', 0),\
			FST::RELATION('0', 1), FST::RELATION('1', 1), FST::RELATION('2', 1), FST::RELATION('3', 1),\
			FST::RELATION('4', 1), FST::RELATION('5', 1), FST::RELATION('6', 1), FST::RELATION('7', 1),\
			FST::RELATION('8', 1), FST::RELATION('9', 1)),\
	/* Состояние 1 (конечное): внутри числа, допускает только цифры */\
	FST::NODE(10,\
			FST::RELATION('0', 1), FST::RELATION('1', 1), FST::RELATION('2', 1), FST::RELATION('3', 1),\
			FST::RELATION('4', 1), FST::RELATION('5', 1), FST::RELATION('6', 1), FST::RELATION('7', 1),\
			FST::RELATION('8', 1), FST::RELATION('9', 1))

#define GRAPH_HEX_BIN_LITERAL 3,\
	/* Состояние 0: ожидаем открывающий апостроф */\
	FST::NODE(1, FST::RELATION('\'', 1)),\
	/* Состояние 1: внутри литерала, допускаем -, 0-9, x/X, b/B, A-F/a-f, до закрывающего апострофа */\
	FST::NODE(28, \
			FST::RELATION('-', 1),\
			FST::RELATION('0', 1), FST::RELATION('1', 1), FST::RELATION('2', 1), FST::RELATION('3', 1), FST::RELATION('4', 1), FST::RELATION('5', 1), FST::RELATION('6', 1), FST::RELATION('7', 1), FST::RELATION('8', 1), FST::RELATION('9', 1),\
			FST::RELATION('x', 1), FST::RELATION('X', 1),\
			FST::RELATION('b', 1), FST::RELATION('B', 1),\
			FST::RELATION('A', 1), FST::RELATION('B', 1), FST::RELATION('C', 1), FST::RELATION('D', 1), FST::RELATION('E', 1), FST::RELATION('F', 1),\
			FST::RELATION('a', 1), FST::RELATION('b', 1), FST::RELATION('c', 1), FST::RELATION('d', 1), FST::RELATION('e', 1), FST::RELATION('f', 1),\
			FST::RELATION('\'', 2)),\
	/* Состояние 2: конечное, после закрывающего апострофа */\
		FST::NODE()

#define GRAPH_ISTRUE 5, \
	FST::NODE(1, FST::RELATION('t',1)),\
	FST::NODE(1, FST::RELATION('r',2)),\
	FST::NODE(1, FST::RELATION('u',3)),\
	FST::NODE(1, FST::RELATION('e',4)),\
	FST::NODE()


#define GRAPH_ISFALSE 6, \
	FST::NODE(1, FST::RELATION('f',1)),\
	FST::NODE(1, FST::RELATION('a',2)),\
	FST::NODE(1, FST::RELATION('l',3)),\
	FST::NODE(1, FST::RELATION('s',4)),\
	FST::NODE(1, FST::RELATION('e',5)),\
	FST::NODE()

#define GRAPH_FUNCTION 9, \
	FST::NODE(1, FST::RELATION('f', 1)),\
    FST::NODE(1, FST::RELATION('u', 2)),\
    FST::NODE(1, FST::RELATION('n', 3)),\
    FST::NODE(1, FST::RELATION('c', 4)),\
    FST::NODE(1, FST::RELATION('t', 5)),\
    FST::NODE(1, FST::RELATION('i', 6)),\
    FST::NODE(1, FST::RELATION('o', 7)),\
    FST::NODE(1, FST::RELATION('n', 8)),\
    FST::NODE()

#define GRAPH_IS 3,\
	FST::NODE(1,FST::RELATION('i',1)),\
	FST::NODE(1,FST::RELATION('s',2)),\
	FST::NODE()

#define GRAPH_POW 4,\
	FST::NODE(1,FST::RELATION('p',1)),\
	FST::NODE(1,FST::RELATION('o',2)),\
	FST::NODE(1,FST::RELATION('w',3)),\
	FST::NODE()
#define GRAPH_RANDOM 7,\
	FST::NODE(1,FST::RELATION('r',1)),\
	FST::NODE(1,FST::RELATION('a',2)),\
	FST::NODE(1,FST::RELATION('n',3)),\
	FST::NODE(1,FST::RELATION('d',4)),\
	FST::NODE(1,FST::RELATION('o',5)),\
	FST::NODE(1,FST::RELATION('m',6)),\
	FST::NODE()
#define GRAPH_LENGTH 7,\
	FST::NODE(1,FST::RELATION('l',1)),\
	FST::NODE(1,FST::RELATION('e',2)),\
	FST::NODE(1,FST::RELATION('n',3)),\
	FST::NODE(1,FST::RELATION('g',4)),\
	FST::NODE(1,FST::RELATION('h',5)),\
	FST::NODE(1,FST::RELATION('t',6)),\
	FST::NODE()
#define GRAPH_COMPARE 8,\
	FST::NODE(1,FST::RELATION('c',1)),\
	FST::NODE(1,FST::RELATION('o',2)),\
	FST::NODE(1,FST::RELATION('m',3)),\
	FST::NODE(1,FST::RELATION('p',4)),\
	FST::NODE(1,FST::RELATION('a',5)),\
	FST::NODE(1,FST::RELATION('r',6)),\
	FST::NODE(1,FST::RELATION('e',7)),\
	FST::NODE()
#define GRAPH_INTEGER 8,\
	FST::NODE(1, FST::RELATION('i',1)),\
	FST::NODE(1, FST::RELATION('n',2)),\
	FST::NODE(1, FST::RELATION('t',3)),\
	FST::NODE(1, FST::RELATION('e',4)),\
	FST::NODE(1, FST::RELATION('g',5)),\
	FST::NODE(1, FST::RELATION('e',6)),\
	FST::NODE(1, FST::RELATION('r',7)),\
	FST::NODE()

#define GRAPH_STRING 7, \
	FST::NODE(1, FST::RELATION('s',1)),\
	FST::NODE(1, FST::RELATION('t',2)),\
	FST::NODE(1, FST::RELATION('r',3)),\
	FST::NODE(1, FST::RELATION('i',4)),\
	FST::NODE(1, FST::RELATION('n',5)),\
	FST::NODE(1, FST::RELATION('g',6)),\
	FST::NODE()
#define GRAPH_SYMBOL 7, \
	FST::NODE(1, FST::RELATION('s',1)),\
	FST::NODE(1, FST::RELATION('y',2)),\
	FST::NODE(1, FST::RELATION('m',3)),\
	FST::NODE(1, FST::RELATION('b',4)),\
	FST::NODE(1, FST::RELATION('o',5)),\
	FST::NODE(1, FST::RELATION('l',6)),\
	FST::NODE()

#define GRAPH_MAIN 5, \
	FST::NODE(1,FST::RELATION('m',1)),\
	FST::NODE(1,FST::RELATION('a',2)),\
	FST::NODE(1,FST::RELATION('i',3)),\
	FST::NODE(1,FST::RELATION('n',4)),\
	FST::NODE()

#define GRAPH_DO 3, \
	FST::NODE(1,FST::RELATION('d',1)),\
	FST::NODE(1,FST::RELATION('o',2)),\
	FST::NODE()

#define GRAPH_WHILE 6, \
	FST::NODE(1,FST::RELATION('w',1)),\
	FST::NODE(1,FST::RELATION('h',2)),\
	FST::NODE(1,FST::RELATION('i',3)),\
	FST::NODE(1,FST::RELATION('l',4)),\
	FST::NODE(1,FST::RELATION('e',5)),\
	FST::NODE()
#define GRAPH_REPEAT 7, \
	FST::NODE(1,FST::RELATION('r',1)),\
	FST::NODE(1,FST::RELATION('e',2)),\
	FST::NODE(1,FST::RELATION('p',3)),\
	FST::NODE(1,FST::RELATION('e',4)),\
	FST::NODE(1,FST::RELATION('a',5)),\
	FST::NODE(1,FST::RELATION('t',6)),\
	FST::NODE()
#define GRAPH_TIMES 6, \
	FST::NODE(1,FST::RELATION('t',1)),\
	FST::NODE(1,FST::RELATION('i',2)),\
	FST::NODE(1,FST::RELATION('m',3)),\
	FST::NODE(1,FST::RELATION('e',4)),\
	FST::NODE(1,FST::RELATION('s',5)),\
	FST::NODE()

#define GRAPH_WRITE 6, \
	FST::NODE(1, FST::RELATION('w',1)),\
	FST::NODE(1, FST::RELATION('r',2)),\
	FST::NODE(1, FST::RELATION('i',3)),\
	FST::NODE(1, FST::RELATION('t',4)),\
	FST::NODE(1, FST::RELATION('e',5)),\
	FST::NODE()

#define GRAPH_WRITELINE 10, \
	FST::NODE(1, FST::RELATION('w',1)),\
	FST::NODE(1, FST::RELATION('r',2)),\
	FST::NODE(1, FST::RELATION('i',3)),\
	FST::NODE(1, FST::RELATION('t',4)),\
	FST::NODE(1, FST::RELATION('e',5)),\
	FST::NODE(1, FST::RELATION('l',6)),\
	FST::NODE(1, FST::RELATION('i',7)),\
	FST::NODE(1, FST::RELATION('n',8)),\
	FST::NODE(1, FST::RELATION('e',9)),\
	FST::NODE()

#define GRAPH_RETURN 7, \
	FST::NODE(1, FST::RELATION('r',1)),\
	FST::NODE(1, FST::RELATION('e',2)),\
	FST::NODE(1, FST::RELATION('t',3)),\
	FST::NODE(1, FST::RELATION('u',4)),\
	FST::NODE(1, FST::RELATION('r',5)),\
	FST::NODE(1, FST::RELATION('n',6)),\
	FST::NODE()

#define GRAPH_TYPE 5, \
	FST::NODE(1,FST::RELATION('t',1)),\
	FST::NODE(1,FST::RELATION('y',2)),\
	FST::NODE(1,FST::RELATION('p',3)),\
	FST::NODE(1,FST::RELATION('e',4)),\
	FST::NODE()

#define GRAPH_VOID 5, \
	FST::NODE(1, FST::RELATION('v',1)),\
	FST::NODE(1, FST::RELATION('o',2)),\
	FST::NODE(1, FST::RELATION('i',3)),\
	FST::NODE(1, FST::RELATION('d',4)),\
	FST::NODE()

#define GRAPH_BOOL_LITERAL 3, \
	FST::NODE(104, \
			FST::RELATION('t',1), FST::RELATION('f',1), FST::RELATION('T',1), FST::RELATION('F',1),\
			FST::RELATION('y',1), FST::RELATION('n',1), FST::RELATION('Y',1), FST::RELATION('N',1),\
			FST::RELATION('d',1), FST::RELATION('D',1), FST::RELATION('l',1), FST::RELATION('L',1),\
			FST::RELATION('a',1), FST::RELATION('A',1), FST::RELATION('e',1), FST::RELATION('E',1),\
			FST::RELATION('r',1), FST::RELATION('R',1), FST::RELATION('u',1), FST::RELATION('U',1),\
			FST::RELATION('s',1), FST::RELATION('S',1), FST::RELATION('o',1), FST::RELATION('O',1),\
			FST::RELATION('i',1), FST::RELATION('I',1), FST::RELATION('h',1), FST::RELATION('H',1),\
			FST::RELATION('1',1), FST::RELATION('0',1), FST::RELATION('+',1), FST::RELATION('-',1)),\
	FST::NODE(104, \
			FST::RELATION('t',2), FST::RELATION('f',2), FST::RELATION('T',2), FST::RELATION('F',2),\
			FST::RELATION('y',2), FST::RELATION('n',2), FST::RELATION('Y',2), FST::RELATION('N',2),\
			FST::RELATION('d',2), FST::RELATION('D',2), FST::RELATION('l',2), FST::RELATION('L',2),\
			FST::RELATION('a',2), FST::RELATION('A',2), FST::RELATION('e',2), FST::RELATION('E',2),\
			FST::RELATION('r',2), FST::RELATION('R',2), FST::RELATION('u',2), FST::RELATION('U',2),\
			FST::RELATION('s',2), FST::RELATION('S',2), FST::RELATION('o',2), FST::RELATION('O',2),\
			FST::RELATION('i',2), FST::RELATION('I',2), FST::RELATION('h',2), FST::RELATION('H',2),\
			FST::RELATION('1',2), FST::RELATION('0',2), FST::RELATION('+',2), FST::RELATION('-',2)),\
	FST::NODE()

file Greibach.h:
#pragma once

typedef short GRBALPHABET; // символы алфавита грамматики терминалы > 0, нетерминалы < 0

namespace GRB
{
	struct Rule		// правило в грамматике Грейбах
	{
		GRBALPHABET nn;			// нетерминал (левый символ правила) < 0
		int iderror;			// идентификатор диагностического сообщения
		short size;				// количество цепочек - правых частей правила
		struct Chain			// цепочка (правая часть правила)
		{
			short size;						// длина цепочки
			GRBALPHABET* nt;				// цепочка терминалов (> 0) и нетерминалов (< 0)
			Chain() { size = 0; nt = 0; };
			Chain(
				short psize,				// количество символов в цепочке 
				GRBALPHABET s, ...			// символы (терминал или нетерминал)
			);
			char* getCChain(char* b);		// получить правую сторону правила
			static GRBALPHABET T(char t) { return GRBALPHABET(t); };    // терминал
			static GRBALPHABET N(char n) { return -GRBALPHABET(n); };   // нетерминал
			static bool isT(GRBALPHABET s) { return s > 0; };	 // терминал?
			static bool isN(GRBALPHABET s) { return !isT(s); };	 // нетерминал?
			static char alphabet_to_char(GRBALPHABET s) { return isT(s) ? char(s) : char(-s); }; // GRBALPHABET->char
		}*chains;							// массив цепочек - правых частей правила 
		Rule() { nn = 0x00; size = 0; };
		Rule(
			GRBALPHABET pnn,		// нетерминал (< 0) 
			int iderror,			// идентификатор диагностического сообщения (Error)
			short psize,			// количество цепочек - правых частей правила
			Chain c, ...			// множество цепочек - правых частей правила
		);
		char* getCRule(				// получить правило в виде N-цепочки (для распечатки)
			char* b,				// буфер
			short nchain			// номер цепочки (правой части) в правиле
		);
		short getNextChain(	// УБРАНО Rule:: - получить следующую за j подходящую цепочку, вернуть её номер или -1
			GRBALPHABET t,			// первый символ цепочки
			Rule::Chain& pchain,	// возвращаемая цепочка
			short j					// номер цепочки
		);
	};

	struct Greibach		// грамматика Грейбах
	{
		short size;		// количество правил
		GRBALPHABET startN;		// стартовый символ
		GRBALPHABET stbottomT;	// дно стека
		Rule* rules;			// множество правил
		Greibach() { short size = 0; startN = 0; stbottomT = 0;	rules = 0; };
		Greibach(
			GRBALPHABET pstartN,	// стартовый символ
			GRBALPHABET pstbottomT, // дно стека
			short psize,			// количество правил
			Rule r, ...				// правила
		);
		short getRule(				// получить правило, возвращающая номер правила или -1
			GRBALPHABET pnn,		// левый символ
			Rule& prule				// возвращаемое правило грамматики
		);
		Rule getRule(short n);		// получить правило по номеру
	};
	Greibach getGreibach();			// получить грамматику
}

file In.h:
#pragma once
#define IN_MAX_LEN_TEXT 1024*1024    // Максимальный размер исходного кода 1MB
#define MAX_LEN_BUFFER  2048
#define IN_WORDS_MAXSIZE 4096        // Максимальное количество слов в таблице слов
#define IN_CODE_ENDL    '\n'
#define IN_CODE_SPACE   ' '
#define IN_CODE_NULL    '\0'
#define IN_CODE_QUOTE   '\"'
#define IN_CODE_APOST   '\''
#define IN_CODE_TILDA   '~'

// Таблица классификации символов для ENV-2025
#define IN_CODE_TABLE {\
    /* 0-15 */   IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,   IN::I, IN::W, IN::N, IN::I,  IN::I, IN::W, IN::I, IN::I,\
    /* 16-31 */  IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,   IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,\
    /* 32-47 */  IN::W, IN::S, IN::Q, IN::O,  IN::O, IN::O, IN::O, IN::A,   IN::S, IN::S, IN::O, IN::O,  IN::S, IN::O, IN::S, IN::O,\
    /* 48-63 */  IN::D, IN::D, IN::D, IN::D,  IN::D, IN::D, IN::D, IN::D,   IN::D, IN::D, IN::S, IN::S,  IN::C, IN::S, IN::C, IN::S,\
    /* 64-79 */  IN::S, IN::H, IN::H, IN::H,  IN::H, IN::H, IN::H, IN::L,   IN::L, IN::L, IN::L, IN::L,  IN::L, IN::L, IN::L, IN::L,\
    /* 80-95 */  IN::L, IN::L, IN::L, IN::L,  IN::L, IN::L, IN::L, IN::L,   IN::L, IN::L, IN::L, IN::S,  IN::K, IN::S, IN::K, IN::L,\
    /* 96-111 */ IN::L, IN::H, IN::H, IN::H,  IN::H, IN::H, IN::H, IN::L,   IN::L, IN::L, IN::L, IN::L,  IN::L, IN::L, IN::L, IN::L,\
    /* 112-127*/ IN::L, IN::L, IN::L, IN::L,  IN::L, IN::L, IN::L, IN::L,   IN::L, IN::L, IN::L, IN::S,  IN::O, IN::S, IN::S, IN::S,\
	\
    /* 128-255 - все запрещенные для ENV-2025 */ \
                IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,   IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,\
                IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,   IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,\
                IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,   IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,\
                IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,   IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,\
                IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,   IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,\
                IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,   IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,\
                IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,   IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,\
                IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I,   IN::I, IN::I, IN::I, IN::I,  IN::I, IN::I, IN::I, IN::I \
}

namespace In
{
	struct InWord
	{
        char word[MAX_LEN_BUFFER];    // слово
        int line;                     // строка в исходном тексте
        int col;                      // позиция в строке (колонка)
        int size;                     // количество слов
	};

    struct IN // исходные данные
	{
		/*
        Коды категорий символов для ENV-2025:
        L - Буквы (A-Z, a-z) - для идентификаторов и ключевых слов
        D - Цифры (0-9) - для целочисленных литералов
        H - Шестнадцатеричные цифры (A-F, a-f)
        B - Двоичные цифры (0, 1)
        O - Операции (+ - * / % =)
        C - Сравнения (< > !) - для ==, !=, <=, >=
        S - Разделители (; , : ( ) { } [ ])
        Q - Строковый литерал (")
        A - Символьный литерал (')
        U - Подчеркивание (_) - для идентификаторов
        W - Пробельные символы (пробел, табуляция)
        N - Перевод строки
        I - Запрещенные символы
        K - Символы для логических литералов (T, F, t, f)
		*/
        enum {
            L = 1024,      // Letter
            D = 2048,      // Digit  
            H = 4096,      // Hex digit
            B = 8192,      // Binary digit
            O = 16384,     // Operator
            C = 32768,     // Comparison
            S = 65536,     // Separator
            Q = 131072,    // Quote (string)
            A = 262144,    // Apostrophe (char)
            U = 524288,    // Underscore
            W = 1048576,   // Whitespace
            N = 2097152,   // Newline
            I = 4194304,   // Invalid
            K = 8388608    // Boolean literal
        };

        int size = 0;           // размер исходного кода 
        int lines = 1;          // количество строк
        int ignor = 0;          // количество проигнорированных символов
        unsigned char* text;    // исходный текст
        int code[256] = IN_CODE_TABLE; // таблица классификации символов
        InWord* words;          // таблица слов
	};

    IN getin(wchar_t infile[], std::ostream* stream); // Ввести и проверить входной поток 
	void addWord(InWord* words, char* word, int line, int col = 0);
	InWord* getWordsTable(std::ostream* stream, unsigned char* text, int* code, int textSize);

	void printTable(InWord* table);
}

file IT.h:
#pragma once
#include"pch.h"
#define ID_MAXSIZE	9					 //макс число символов идентификатора
#define SCOPED_ID_MAXSIZE   (ID_MAXSIZE*2-1) //макс число символов идентификатор + область видимости
#define MAXSIZE_TI		4096			 //макс число количество строк в таблице идентификаторов
#define TI_INT_DEFAULT	0x00000000		 //значение по умолчанию для integer
#define TI_STR_DEFAULT	0x00			 //значение по умолчанию для sting
#define TI_SYM_DEFAULT	0x00			 //значение по умолчанию для symbol;
#define TI_NULLIDX		0xffffffff		 //нет элемента таблицы идентификаторов
#define STR_MAXSIZE	255				 //максимальная длина строкового литерала
#define TI_INT_MAXSIZE   32767			 //максимальное значение для типа integer (2 байта)
#define TI_INT_MINSIZE  -32768			 //минимальное значение для типа integer (2 байта)
#define MAX_PARAMS_COUNT 5			   	 //максимальное количество параметров у функции
#define POW_PARAMS_CNT 2				 //кол-во параметров у функции pow
#define RANDOM_PARAMS_CNT 2				 //кол-во параметров у функции rand
#define LENGHT_PARAMS_CNT 1				//кол-во параметров у функции lenght
#define COMPARE_PARAMS_CNT 2				//кол-во параметров у функции compare
#define RANDOM_TYPE IT::IDDATATYPE::INT
#define POW_TYPE IT::IDDATATYPE::INT
#define LENGHT_TYPE IT::IDDATATYPE::INT
#define COMPARE_TYPE IT::IDDATATYPE::INT

namespace IT			// таблица идентификаторов
{
	enum IDDATATYPE { INT = 1, STR = 2, SYM =3,PROC =4, UNDEF };								//типы данных идентификаторов: числовой, строковый,символьный неопределенный
	enum IDTYPE { V = 1, F = 2, P = 3, L = 4, S = 5, Z = 6 };									//типы идентификаторов: V = переменная, F = функция, P =параметр, L =литерал, S = стандартная функция Z - знак
	enum STDFNC { F_POW,F_POWER, F_RANDOM, F_LENGTH, F_COMPARE, F_NOT_STD };											//стандартные функции
	static const IDDATATYPE POW_PARAMS[] = { IT::IDDATATYPE::INT, IT::IDDATATYPE::INT };//параметры функции  											//параметры функции 											//параметры функции
	static const IDDATATYPE RANDOM_PARAMS[] = { IT::IDDATATYPE::INT, IT::IDDATATYPE::INT };//параметры функции  											//параметры функции 											//параметры функции
	static const IDDATATYPE LENGHT_PARAMS[] = { IT::IDDATATYPE::STR };//параметры функции length
	static const IDDATATYPE COMPARE_PARAMS[] = { IT::IDDATATYPE::STR, IT::IDDATATYPE::STR };//параметры функции compare
	struct Entry	// строка таблицы идентификаторов
	{
		int			idxfirstLE;			// индекс первой строки в таблице лексем
		char	id[SCOPED_ID_MAXSIZE];		// индентификатор (автоматически усекается до ID_MAXSIZE)
		IDDATATYPE	iddatatype;			// тип данных
		IDTYPE		idtype;				// тип идентификатора

		union
		{
			short vint;					// значение integer (2 байта)
			struct
			{
				int len;							// количество символов в string
				 char str[STR_MAXSIZE - 1];	// символы string
			} vstr;									// значение string
			char symbol;							//значение symbol
			struct
			{
				int count;					// количество параметров функции
				IDDATATYPE *types;			//типы параметров функции
			} params;
		} value;		// значение идентификатора

		Entry()							//конструктор без параметров
		{
			this->value.vint = TI_INT_DEFAULT;
			this->value.vstr.len = NULL;
			this->value.params.count = NULL;
			this->value.symbol = NULL;
		};
		Entry(const char* id, int idxLT, IDDATATYPE datatype, IDTYPE idtype) //конструктор с параметрами
		{
			strncpy_s(this->id, id, SCOPED_ID_MAXSIZE - 1);
			this->idxfirstLE = idxLT;
			this->iddatatype = datatype;
			this->idtype = idtype;
		};
	};

	struct IdTable				// экземпляр таблицы идентификаторов
	{
		int maxsize;			// емкость таблицы идентификаторов < TI_MAXSIZE
		int size;				// текущий размер таблицы идентификаторов < maxsize
		Entry* table;			// массив строк таблицы идентификаторов
	};

	IdTable Create(int size);		// емкость таблицы идентификаторов < TI_MAXSIZE// создать таблицу идентификаторов

	void Add(				// добавить строку в таблицу идентификаторов
		IdTable& idtable,	// экземпляр таблицы идентификаторов
		Entry entry			// строка таблицы идентификаторов
	);
	int isId(				// возврат: номер строки (если есть), TI_NULLIDX (если нет)
		IdTable& idtable,	// экземпляр таблицы идентификаторов
		const char id[SCOPED_ID_MAXSIZE]	// идентификатор
	);
	bool SetValue(IT::Entry* entry, const char* value);	//задать значение идентификатора
	bool SetValue(IT::IdTable& idtable, int index, const char* value);
	void writeIdTable(std::ostream *stream, IT::IdTable &idtable); //вывести таблицу идентификаторов
};

file LexAnaliz.h:
#pragma once
#include "pch.h"

#define TYPE_INTEGER	"integer"
#define TYPE_STRING		"string"
#define TYPE_SYMBOL		"symbol"
#define RANDOM			"random"
#define TYPE_VOID		"void"
#define MAIN			"main"
#define POW				"pow"
#define LENGHT			"lenght"
#define COMPARE			"compare"

#define ISTYPE(str) ( !strcmp(str, TYPE_INTEGER) || !strcmp(str, TYPE_STRING) )

namespace Lex
{
	struct LEX
	{
		LT::LexTable lextable;
		IT::IdTable	idtable;
		LEX() {}
	};
	struct Graph
	{
		char lexema;
		FST::FST graph;
	};
	IT::Entry* getEntry		// формирует и возвращает строку ТИ
	(
		Lex::LEX& tables,						// ТЛ + ТИ
		char lex,								// лексема
		char* id,								// идентификатор
		char* idtype,							// предыдущая (тип)
		bool isParam,							// признак параметра функции
		bool isFunc,							// признак функции
		Log::LOG log,							// протокол
		int line,								// строка в исходном тексте
		bool& rc_err							// флаг ошибки(по ссылке)
	);

	struct ERROR_S									// тип исключения для throw ERROR_THROW | ERROR_THROW_IN
	{
		int id;
		char message[ERROR_MAXSIZE_MESSAGE];			// сообщение			
		struct
		{
			short line = -1;						//номер строки (0, 1, 2, ...)
			short col = -1;						    //номер позиции в строке(0, 1, 2, ...)
		} position;
	};

	bool analyze(LEX& tables, In::IN& in, Log::LOG& log, Parm::PARM& parm);
	int getIndexInLT(LT::LexTable &lextable, int itTableIndex);					// индекс первой встречи в таблице лексем
};

file Log.h:
#pragma once
#include <fstream>
#include "In.h"
#include "Parm.h"
#include "Error.h"
namespace Log //работа с протоколом
{
	struct LOG //протокол
	{
		wchar_t logfile[PARM_MAX_SIZE]; //имя файла протокола
		std::ofstream* stream; //выходной поток протокола
	};

	static const LOG INITLOG = {L"",NULL};			 //  структура для начальной инициализацтт LOG
	LOG getlog(wchar_t logfile[]);					 //  сформулировать структуру LOG
	void WriteLine(LOG log,const char* c,...);	     //  вывести в протокол кокатенацию строк
	void WriteLine(LOG, const wchar_t* c, ...);      //  вывести в протокол конкатенацию строк
	void WriteLineConsole(char * c, ...);
	void WriteLog(LOG log);							 //  вывести в протокол заголовок
	void WriteParm(LOG log, Parm::PARM parm);		 //  вывести в протокол информацию о входных параметров
	void WriteIn(LOG log, In::IN in);				 //  вывести в протокол информацию о входном потоке
	void WriteError(std::ostream *stream, Error::ERROR e);//вывести в протокол информацию об ошибке
	void Close(LOG log);							 //закрыть протокол	


}

file LT.h:
#pragma once
#include "pch.h"
#define	LEXEMA_FIXSIZE   1	        //размер лексемы
#define	LT_MAXSIZE		 4096	    //максимальное количество строк в ТЛ
#define	NULLDX_TI	 0xffffffff	//нет элемента ТИ
#define LEX_SEPARATORS	 'S'	// разделители
#define	LEX_ID_TYPE    	 't'	// типы данных		
#define	LEX_STDFUNC    	 'p'	// стандартные библиотеки		
#define	LEX_ID			 'i'	// идентификаторы		
#define	LEX_LITERAL		 'l'	// литералы		
#define	LEX_FUNCTION     'f'	// function		
#define	LEX_MAIN		 'm'	// main		
#define	LEX_SEPARATOR	 ';'	// разделитель инструкций
#define	LEX_COMMA		 ','	// разделитель параметров 		
#define	LEX_LEFTBRACE	 '{'	// начало блока		
#define	LEX_BRACELET	 '}'	// конец блока		
#define	LEX_SQ_LBRACELET '['	// начало блока		
#define	LEX_SQ_RBRACELET ']'	// конец блока		
#define	LEX_LEFTHESIS	 '('	// начало списка параметров		
#define	LEX_RIGHTTHESIS	 ')'	// конец списка параметров		
#define	LEX_PLUS		 '+'	// сложение	
#define	LEX_MINUS		 '-'	// вычитание
#define	LEX_STAR		 '*'	// умножение
#define	LEX_INCR		 ':'	// сокращенная форма записи
#define LEX_DIRSLASH	 '/'	// деление
#define LEX_PROCENT		 '%'	// остаток от деления
#define	LEX_EQUAL		 '='	// присваивание				
#define LEX_IS			 '?'	// is
#define LEX_TILDA		 '~'	// отрицательный идентификатор
#define LEX_WHILE		 'c'	// while (deprecated)
#define LEX_REPEAT		 'R'	// repeat
#define LEX_TIMES		 'T'	// times
#define LEX_ISTRUE		 'r'	// ложный блок
#define LEX_ISFALSE		 'w'	// истинный блок
#define LEX_DO			 'd'	// do
#define LEX_WRITE		 'o'	// вывод
#define LEX_NEWLINE		 '^'	// вывод с переводом строки
#define LEX_RETURN		 'e'	// выход из функции
#define LEX_VOID		 'g'	// void
#define LEX_TYPE		 'n'	// объявления переменных
#define LEX_MORE		 '>'	// проверка на больше
#define LEX_LESS		 '<'	// проверка на меньше
#define LEX_EQUALS		 '&'	// проверка на равенство
#define LEX_SUBST		 '@'	// вызов функции в польской записи 
#define LEX_NOTEQUALS	 '!'	// проверка на неравенство

namespace LT		// таблица лексем
{
	struct Entry	// строка таблицы лексем
	{
		unsigned char lexema;	// лексема
		int sn;							// номер строки в исходном тексте
		int col;						// позиция в строке (колонка)
		int idxTI;						// индекс в таблице идентификаторов или LT_TI_NULLIDX

		Entry();
		Entry(unsigned char lexema, int snn, int coln = 0, int idxti = NULLDX_TI);

	};

	struct LexTable						// экземпляр таблицы лексем
	{
		int maxsize;					// емкость таблицы лексем < LT_MAXSIZE
		int size;						// текущий размер таблицы лексем < maxsize
		Entry* table;					// массив строк таблицы лексем
	};

	LexTable Create(		// создать таблицу лексем
		int size			// емкость таблицы лексем < LT_MAXSIZE
	);

	void Add(				// добавить строку в таблицу лексем
		LexTable& lextable,	// экземпляр таблицы лексем
		Entry entry			// строка таблицы лексем
	);

	Entry GetEntry(			// получить строку таблицы лексем
		LexTable& lextable,	// экземпляр таблицы лексем
		int n				// номер получаемой строки
	);

	void Delete(LexTable& lextable);	// удалить таблицу лексем (освободить память)

	Entry writeEntry(					// заполнить строку таблицы лексем
		Entry &entry,
		unsigned char lexema,
		int indx,
		int line,
		int col = 0
	);
	void showTable(LexTable lextable, Log::LOG &log);						// вывод таблицы лексем
	void writeLexTable(std::ostream *stream, LT::LexTable &lextable);		//вывести таблицу лексем
	void writeLexemsOnLines(std::ostream *stream, LT::LexTable &lextable);	//вывести лексемы по строкам
};

file MFST.h:
#pragma once
#pragma once
#include "pch.h"

#define MFST_DIAGN_MAXSIZE 2*ERROR_MAXSIZE_MESSAGE
#define MFST_DIAGN_NUMBER 3

#define MFST_TRACE_START(LOG) *log.stream << std::setw( 4)<<std::left<<"Шаг"<<":" \
	<< std::setw(20) << std::left << "Правило"  \
	<< std::setw(30) << std::left << "Входная лента" \
	<< std::setw(20) << std::left << "Стек" \
	<< std::endl;

#define MFST_TRACE1(LOG) *log.stream <<std::setw( 4)<<std::left<<++FST_TRACE_n<<":" \
	<< std::setw(20) << std::left << rule.getCRule(rbuf, nrulechain)  \
	<< std::setw(30) << std::left << getCLenta(lbuf, lenta_position) \
	<< std::setw(20) << std::left << getCSt(sbuf) \
	<< std::endl;

#define MFST_TRACE2(LOG)    *log.stream <<std::setw( 4)<<std::left<<FST_TRACE_n<<":" \
	<< std::setw(20) << std::left << " "  \
	<< std::setw(30) << std::left << getCLenta(lbuf, lenta_position) \
	<< std::setw(20) << std::left << getCSt(sbuf) \
	<< std::endl;

#define MFST_TRACE3(LOG)     *log.stream<<std::setw( 4)<<std::left<<++FST_TRACE_n<<":" \
	<< std::setw(20) << std::left << " "  \
	<< std::setw(30) << std::left << getCLenta(lbuf, lenta_position) \
	<< std::setw(20) << std::left << getCSt(sbuf) \
	<< std::endl;

#define MFST_TRACE4(LOG, c) *log.stream<<std::setw(4)<<std::left<<++FST_TRACE_n<<": "<<std::setw(20)<<std::left<<c<<std::endl;
#define MFST_TRACE5(LOG, c) *log.stream<<std::setw(4)<<std::left<<  FST_TRACE_n<<": "<<std::setw(20)<<std::left<<c<<std::endl;

#define MFST_TRACE6(LOG,c,k) *log.stream<<std::setw(4)<<std::left<<++FST_TRACE_n<<": "<<std::setw(20)<<std::left<<c<<k<<std::endl;

#define MFST_TRACE7(LOG)  *log.stream<<std::setw(4)<<std::left<<state.lenta_position<<": "\
	<< std::setw(20) << std::left << rule.getCRule(rbuf, state.nrulechain) \
	<< std::endl;


typedef std::stack<short> MFSTSTACK;		// стек автомата

namespace MFST
{
	struct MfstState				// состояние автомата (для сохранения)
	{
		short lenta_position;			// позиция на ленте
		short nrule;					// номер текущего правила
		short nrulechain;				// номер текущей цепочки, текущего правила
		MFSTSTACK st;					// стек автомата
		MfstState();
		MfstState(
			short pposition,			// позиция на ленте
			MFSTSTACK pst,				// стек автомата
			short pnrulechain			// номер текущей цепочки, текущего правила
		);
		MfstState(
			short pposition,			// позиция на ленте
			MFSTSTACK pst,				// стек автомата
			short pnrule,				// номер текущего правила
			short pnrulechain			// номер текущей цепочки, текущего правила
		);
	};

	struct Mfst				// магазинный автомат
	{
		enum RC_STEP {			// код возвтара функции step
			NS_OK,				// найдено правило и цепочка, цепочка записана в стек
			NS_NORULE,			// не найдено правило грамматики (ошибка в грамматике)
			NS_NORULECHAIN,		// не найдена подходящая цепочка правила (ошибка в исходном коде)
			NS_ERROR,			// неизвестный нетерминальный символ грамматики
			TS_OK,				// тек. символ ленты == вершине стека, продвинулась лента, pop стека
			TS_NOK,				// тек. символ ленты != вершине стека, восстановлено состояние
			LENTA_END,			// текущая позиция ленты >= lenta_size
			SURPRISE			// неожиданный код возврата (ошибка в step)
		};

		struct MfstDiagnosis	// диагностика
		{
			short lenta_position;		// позиция на ленте
			RC_STEP rc_step;			// код завершения шага
			short nrule;				// номер правила
			short nrule_chain;			// номер цепочки правила
			MfstDiagnosis();
			MfstDiagnosis(
				short plenta_position,	// позиция на ленте
				RC_STEP prt_step,		// код завершения шага
				short pnrule,			// номер правила
				short pnrule_chain		// номер цепочки правила
			);
		} diagnosis[MFST_DIAGN_NUMBER];		// последние самые глубокие сообщения

		GRBALPHABET* lenta;				// перекодированная (TS/NS) лента (из LEX)
		short lenta_position;			// текущая позиция на ленте
		short nrule;					// номер текущего правила
		short nrulechain;				// номер текущей цепочки, текущего правила
		short lenta_size;				// размер ленты
		GRB::Greibach grebach;			// грамматика Грейбах
		Lex::LEX lex;						// результат работы лексического анализатора
		MFSTSTACK st;					// стек автомата
		std::stack<MfstState> storestate;	// стек для сохранения состояний 
		Mfst();
		Mfst(
			Lex::LEX plex,			//результат работы лексического анализатора
			GRB::Greibach pgrebach		//грамматика Грейбах
		);
		char* getCSt(char* buf);		// получить содержимое стека
		char* getCLenta(char* buf, short pos, short n = 25);	// лента: n символов с pos
		const char* getDiagnosis(short n, char* buf);		// получить n-ю строку диагностики или 0х00
		bool savestate(const Log::LOG &log);				// сохранить состояние автомата
		bool reststate(const Log::LOG &log);			// восстановить состояние автомата
		bool push_chain(				// поместить цепочку правила в стек
			GRB::Rule::Chain chain		// цепочка правила
		);
		RC_STEP step(const Log::LOG &log);					// выполнить шаг автомата
		bool start(const Log::LOG &log);					// запустить автомат
		bool savediagnosis(
			RC_STEP pprc_step			// код завершения шага
		);
		void printrules(const Log::LOG &log);				// вывести последовательность правил

		struct Deducation		// вывод
		{
			short size;			// количество шагов в выводе
			short* nrules;		// номера правил грамматики
			short* nrulechains;	// номера цепочек правик грамматики (nrules)
			Deducation() { size = 0; nrules = 0; nrulechains = 0; };
		} deducation;

		bool savededucation();	// сохранить дерево вывода
	};
}

file Parm.h:
#pragma once
#define PARM_IN L"-in:"					//ключ для файла исходного кода
#define PARM_OUT L"-out:"				//ключ для файла объектного кода
#define PARM_LOG L"-log:"				//ключ для файла журнала
#define PARM_MAX_SIZE 300				//максимальная длина строки параметра
#define PARM_OUT_DEFAULT_EXT L".asm"//расширение файла объектного кода по умолчанию
#define PARM_LOG_DEFAULT_EXT L".log"	//расширение файла протокола по умолчанию

namespace Parm				//обработка входных параметров
{
	struct PARM				//входные параметры
	{
		wchar_t in[PARM_MAX_SIZE];		//-in:	имя файла исходного кода
		wchar_t out[PARM_MAX_SIZE];		//-out:	имя файла объектного кода
		wchar_t log[PARM_MAX_SIZE];		//-log:	имя файла протокола
	};

	PARM getparm(int argc, _TCHAR* argv[]);	//сформировать struct PARM на основе парметров функции main
}

file pch.h:
// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.

#ifndef PCH_H
#define PCH_H
#include <SDKDDKVer.h>
#include <stdio.h>
#include <tchar.h>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <fstream>
#include <string>
#include <iomanip>
#include <ctime>
#include <locale>
#include <cwchar>
#include <mbstring.h>
#include <stack>
#include <queue>
#include <vector>

#include "Log.h"
#include "Error.h"
#include "Parm.h"
#include "LT.h"
#include "IT.h"
#include "In.h"
#include "FST.h"
#include "Graphs.h"
#include "LexAnaliz.h"
#include "Greibach.h"
#include "MFST.h"
#include "Semantic.h"
#include "PolishNotation.h"
#include "Generator.h"
#endif PCH_H

file PolishNotation.h:
#pragma once
#include "pch.h"

typedef std::vector <LT::Entry> ltvec;
typedef std::vector <int> intvec;

namespace Polish
{
	int PolishNotation(int i, Lex::LEX& lex);
	int getPriority(unsigned char e);
	int searchExpression(Lex::LEX lex);
};

file Rule.h:
#pragma once
#pragma once
#include "pch.h"
#define GRB_ERROR_SERIES 600
#define NS(n)	GRB::Rule::Chain::N(n)
#define TS(n)	GRB::Rule::Chain::T(n)
#define ISNS(n)	GRB::Rule::Chain::isN(n)

namespace GRB
{
	Greibach greibach(NS('S'), TS('$'), 20,

		Rule(NS('S'), GRB_ERROR_SERIES , 3,						// Неверная структура программы	
			Rule::Chain(6, TS('t'), TS('f'), TS('i'), NS('P'), NS('T'), NS('S')),
			Rule::Chain(6, TS('g'), TS('f'), TS('i'), NS('P'), NS('G'), NS('S')),
			Rule::Chain(4, TS('m'), TS('{'), NS('K'), TS('}'))
		),

		Rule(NS('T'), GRB_ERROR_SERIES + 2, 2,								// Ошибка в теле функции
			Rule::Chain(3, TS('{'), NS('Q'), TS('}')),
			Rule::Chain(4, TS('{'), NS('K'), NS('Q'), TS('}'))
		),
		
		Rule(NS('P'), GRB_ERROR_SERIES + 1, 2,								// Не найден список параметров функции	
			Rule::Chain(3, TS('('), NS('E'), TS(')')),
			Rule::Chain(2, TS('('), TS(')'))
		),

		Rule(NS('E'), GRB_ERROR_SERIES + 3, 2,								// Ошибка в списке параметров функции						
			Rule::Chain(4, TS('t'), TS('i'), TS(','), NS('E')),
			Rule::Chain(2, TS('t'), TS('i'))
		),

		Rule(NS('F'), GRB_ERROR_SERIES + 4, 2,								// Ошибка в вызове функции						
			Rule::Chain(3, TS('('), NS('N'), TS(')')),
			Rule::Chain(2, TS('('), TS(')'))
		),

		Rule(NS('N'), GRB_ERROR_SERIES + 5, 4,								// Ошибка в списке параметров функции		
			Rule::Chain(1, TS('i')),
			Rule::Chain(1, TS('l')),
			Rule::Chain(3, TS('i'), TS(','), NS('N')),
			Rule::Chain(3, TS('l'), TS(','), NS('N'))
		),

		Rule(NS('R'), GRB_ERROR_SERIES + 6, 4,								// Ошибка при констуировании условного выражения	
			Rule::Chain(2, TS('r'), NS('Y')),
			Rule::Chain(2, TS('w'), NS('Y')),
			Rule::Chain(4, TS('r'), NS('Y'), TS('w'), NS('Y')),
			Rule::Chain(4, TS('w'), NS('Y'), TS('r'), NS('Y'))
		),
Rule(NS('Z'), GRB_ERROR_SERIES + 8, 4,								// Ошибка в условии цикла/условного выражения	
	Rule::Chain(3, TS('i'), NS('L'), TS('i')),
	Rule::Chain(3, TS('i'), NS('L'), TS('l')),
	Rule::Chain(3, TS('l'), NS('L'), TS('l')),
	Rule::Chain(3, TS('l'), NS('L'), TS('i'))
),

Rule(NS('L'), GRB_ERROR_SERIES + 9, 4,								// Неверный условный оператор		
	Rule::Chain(1, TS('<')),
	Rule::Chain(1, TS('>')),
	Rule::Chain(1, TS('&')),
	Rule::Chain(1, TS('!'))
),

Rule(NS('A'), GRB_ERROR_SERIES + 10, 5,											// Неверный арифметический оператор
	Rule::Chain(1, TS('+')),
	Rule::Chain(1, TS('-')),
	Rule::Chain(1, TS('*')),
	Rule::Chain(1, TS('%')),
	Rule::Chain(1, TS('/'))
),
Rule(NS('W'), GRB_ERROR_SERIES + 11, 14,										// Ошибка в арифметичском выражении
	Rule::Chain(1, TS('i')),
	Rule::Chain(1, TS('l')),
	Rule::Chain(3, TS('('), NS('W'), TS(')')),
	Rule::Chain(4, TS('('), TS('-'), TS('i'), TS(')')),
	Rule::Chain(6, TS('('), TS('-'), TS('i'), TS(')'), NS('A'), NS('W')),
	Rule::Chain(5, TS('('), NS('W'), TS(')'), NS('A'), NS('W')),
	Rule::Chain(2, TS('-'), TS('l')),											// унарный минус перед литералом (-10)
	Rule::Chain(3, TS('-'), TS('l'), NS('A'), NS('W')),							// унарный минус перед литералом с операцией
	Rule::Chain(2, TS('i'), NS('F')),
	Rule::Chain(2, TS('p'), NS('F')),
	Rule::Chain(3, TS('i'), NS('A'), NS('W')),
	Rule::Chain(3, TS('l'), NS('A'), NS('W')),
	Rule::Chain(4, TS('i'), NS('F'), NS('A'), NS('W')),
	Rule::Chain(4, TS('p'), NS('F'), NS('A'), NS('W'))
),

Rule(NS('K'), GRB_ERROR_SERIES + 12, 22,							// Недопустимая синтаксическая конструкция
	Rule::Chain(7, TS('n'), TS('t'), TS('i'), TS('='), NS('V'), TS(';'), NS('K')),	// декларация + присваивание
	Rule::Chain(7, TS('n'), TS('t'), TS('i'), TS('='), NS('W'), TS(';'), NS('K')),	// декларация + присваивание
	Rule::Chain(5, TS('n'), TS('t'), TS('i'), TS(';'), NS('K')),	// декларация
	Rule::Chain(5, TS('i'), TS('='), NS('W'), TS(';'), NS('K')),	// присваивание
	Rule::Chain(5, TS('i'), TS(':'), NS('V'), TS(';'), NS('K')),	// присваивание

	Rule::Chain(4, TS('o'), NS('V'), TS(';'), NS('K')),				// вывод
	Rule::Chain(4, TS('^'), NS('V'), TS(';'), NS('K')),						// перевод строки
	Rule::Chain(4, TS('?'), NS('Z'), NS('R'), NS('K')),				// is
	Rule::Chain(5, TS('c'), NS('Z'), TS('d'), NS('H'), NS('K')),						// while (deprecated)
	Rule::Chain(6, TS('R'), TS('l'), TS('T'), TS('d'), NS('H'), NS('K')),			// repeat <число> times do [ ... ]
	Rule::Chain(6, TS('i'), TS('='), TS('U'), NS('F'), TS(';'), NS('K')),	// присваивание c помощью вызова функции 

	Rule::Chain(4, TS('i'), NS('F'), TS(';'), NS('K')),				// вызов функции

	Rule::Chain(6, TS('n'), TS('t'), TS('i'), TS('='), NS('V'), TS(';')),	// декларация + присваивание
	Rule::Chain(6, TS('n'), TS('t'), TS('i'), TS('='), NS('W'), TS(';')),	// декларация + присваивание
	Rule::Chain(4, TS('i'), TS('='), NS('W'), TS(';')),				// присваивание
	Rule::Chain(4, TS('i'), TS(':'), NS('V'), TS(';')),	// присваивание
	Rule::Chain(4, TS('n'), TS('t'), TS('i'), TS(';')),				// декларация
	Rule::Chain(3, TS('o'), NS('V'), TS(';')),						// вывод
	Rule::Chain(3, TS('^'), NS('V'), TS(';')),								// перевод строки
	Rule::Chain(3, TS('?'), NS('Z'), NS('R')),						// is
	Rule::Chain(4, TS('c'), NS('Z'), TS('d'), NS('H')),				// while (deprecated)
	Rule::Chain(5, TS('R'), TS('l'), TS('T'), TS('d'), NS('H')),	// repeat <число> times do [ ... ] (deprecated)
	Rule::Chain(5, TS('R'), TS('l'), TS('T'), TS('d'), NS('H')),	// repeat <число> times do [ ... ]
	Rule::Chain(5, TS('i'), TS('='), TS('U'), NS('F'), TS(';'))	,	// присваивание c помощью вызова функции
	Rule::Chain(3, TS('i'), NS('F'), TS(';'))			// вызов функции
),

Rule(NS('X'), GRB_ERROR_SERIES + 13, 12,								// Недопустимая синтаксическая конструкция в теле цикла/условного выражения	
	Rule::Chain(5, TS('i'), TS('='), NS('W'), TS(';'), NS('X')),	// присваивание
	Rule::Chain(5, TS('i'), TS(':'), NS('V'), TS(';'), NS('X')),	// присваивание
	Rule::Chain(4, TS('o'), NS('V'), TS(';'), NS('X')),				// вывод
	Rule::Chain(4, TS('^'), NS('V'), TS(';'), NS('X')),						// перевод строки
	Rule::Chain(6, TS('i'), TS('='), TS('U'), NS('F'), TS(';'), NS('K')),	// присваивание c помощью вызова функции 

	Rule::Chain(4, TS('i'), NS('F'), TS(';'), NS('K')),				// вызов функции

	Rule::Chain(4, TS('i'), TS('='), NS('W'), TS(';')),				// присваивание
	Rule::Chain(3, TS('o'), NS('V'), TS(';')),						// вывод
	Rule::Chain(3, TS('^'), NS('V'), TS(';')),								// перевод строки
	Rule::Chain(4, TS('i'), TS(':'), NS('V'), TS(';')),	// присваивание
	Rule::Chain(5, TS('i'), TS('='), TS('U'), NS('F'), TS(';'))	,	// присваивание c помощью вызова функции 

	Rule::Chain(3, TS('i'), NS('F'), TS(';'))				// вызов функции
),
Rule(NS('Q'), GRB_ERROR_SERIES + 7, 4,						// Ошибка при конструировании return
	Rule::Chain(3, TS('e'), NS('V'), TS(';')),
	Rule::Chain(6, TS('e'), TS('('), TS('-'), TS('i'), TS(')'), TS(';')),
	Rule::Chain(2, TS('e'), TS(';')),
	Rule::Chain(5, TS('e'), TS('('), TS('l'), TS(')'), TS(';'))
),
Rule(NS('B'), GRB_ERROR_SERIES + 14, 4,						// Ошибка при конструировании условного выражения в цикле
	Rule::Chain(3, TS('?'), NS('Z'), NS('R')),
	Rule::Chain(4, TS('?'), NS('Z'), NS('R'), NS('X')),
	Rule::Chain(5, TS('?'), NS('Z'), NS('R'), NS('X'), NS('B')),
	Rule::Chain(4, TS('?'), NS('Z'), NS('R'), NS('B'))
),
Rule(NS('V'), GRB_ERROR_SERIES + 15, 2,						// Правила для идентификаторов или литералов	
	Rule::Chain(1, TS('i')),
	Rule::Chain(1, TS('l'))
),
Rule(NS('Y'), GRB_ERROR_SERIES + 16, 3,						// Ошибка в теле условного выражения
	Rule::Chain(4, TS('['), NS('X'), NS('Q'), TS(']')),
	Rule::Chain(3, TS('['), NS('X'), TS(']')),
	Rule::Chain(3, TS('['), NS('Q'), TS(']'))
),
Rule(NS('U'), GRB_ERROR_SERIES + 3, 2,						// Правила для идентификатора функции	
	Rule::Chain(1, TS('i')),
	Rule::Chain(1, TS('p'))
),
Rule(NS('G'), GRB_ERROR_SERIES + 2, 2,						// ошибка в теле процедуры
	Rule::Chain(4, TS('{'), TS('e'), TS(';'), TS('}')),
	Rule::Chain(5, TS('{'), NS('K'), TS('e'), TS(';'), TS('}'))
),
Rule(NS('H'), GRB_ERROR_SERIES + 17, 3,						// ошибка в теле цикла	
	Rule::Chain(4, TS('['), NS('X'), NS('B'), TS(']')),
		Rule::Chain(3, TS('['), NS('B'), TS(']')),
		Rule::Chain(3, TS('['), NS('X'), TS(']'))
	)
		

);
}

file Semantic.h:
#pragma once
#include "pch.h"

namespace Semantic
{
	bool semanticsCheck(Lex::LEX& tables, Log::LOG& log);
};


Файлы проекта ENV2025Lib:
file ENV2025Lib.cpp:
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <ctime>

extern "C" {

    // Функция сравнения строк для ENV-2025
    int __stdcall compare(char* str1, char* str2)
    {
        if (str1 == nullptr || str2 == nullptr)
            return 0;
        int result = strcmp(str1, str2);
        if (result < 0) return -1;
        if (result > 0) return 1;
        return 0;
    }

    // Функция вычисления длины строки для ENV-2025
    int __stdcall lenght(char* str)
    {
        if (str == nullptr)
            return 0;
        return strlen(str);
    }

    // Вывод целого числа
    int __stdcall outnum(int value)
    {
        std::cout << value;
        return 0;
    }

    // Вывод строки
    int __stdcall outstr(char* ptr)
    {
        if (ptr == nullptr)
            return 0;

        for (int i = 0; ptr[i] != '\0'; i++)    
            std::cout << ptr[i];
        return 0;
    }

    // Вывод целого числа с переводом строки
    int __stdcall outnumline(int value)
    {
        std::cout << value << std::endl;
        return 0;
    }

    // Вывод строки с переводом строки
    int __stdcall outstrline(char* ptr)
    {
        if (ptr == nullptr)
        {
            std::cout << std::endl;
            return 0;
        }

        for (int i = 0; ptr[i] != '\0'; i++)
            std::cout << ptr[i];
        std::cout << std::endl;
        return 0;
    }

    // Ожидание нажатия клавиши
    int __stdcall system_pause()
    {
        system("pause");
        return 0;
    }

    // Генерация случайного числа от min до max
    int __stdcall random(int min, int max)
    {
        static bool initialized = false;
        if (!initialized) {
            srand((unsigned int)time(NULL));
            initialized = true;
        }
        if (min >= max)
            return min;
        return min + (rand() % (max - min + 1));
    }

    // Возведение в степень
    int __stdcall power(int base, int exponent)
    {
        if (exponent == 0)
            return 1;
        if (exponent < 0)
            return 0; // Для целых чисел отрицательные степени не поддерживаются
        
        int result = 1;
        for (int i = 0; i < exponent; i++)
        {
            result *= base;
        }
        return result;
    }
}

file ENV2025Lib.h:
#pragma once

extern "C" {
    int __stdcall compare(char* str1, char* str2);
    int __stdcall lenght(char* str);
    int __stdcall outnum(int value);
    int __stdcall outstr(char* ptr);
    int __stdcall outnumline(int value);
    int __stdcall outstrline(char* ptr);
    int __stdcall system_pause();
    int __stdcall random(int max);
    int __stdcall power(int base, int exponent);
}

Файлы проекта Assembler:
file in.txt.asm:
.586
.model flat, stdcall
OPTION CASEMAP:NONE
includelib libucrt.lib
includelib kernel32.lib
includelib ENV2025Lib.lib
ExitProcess PROTO :DWORD 
.stack 65536

 outnum PROTO : DWORD

 outstr PROTO : DWORD

 outstrline PROTO : DWORD

 outnumline PROTO : DWORD

 system_pause PROTO

 random PROTO : DWORD, : DWORD

 lenght PROTO : DWORD

 power PROTO : DWORD, : DWORD

 compare PROTO : DWORD, : DWORD
.const
 null_division BYTE 'ERROR: DIVISION BY ZERO', 0
 overflow BYTE 'ERROR: VARIABLE OVERFLOW', 0 
	L1 SWORD 26
	L2 BYTE 'x (hex) = ', 0
	L3 SWORD -27
	L4 BYTE 'q (negative hex) = ', 0
	L5 SWORD 10
	L6 BYTE 'y (binary) = ', 0
	L7 SWORD -13
	L8 BYTE 'z (negative binary) = ', 0
	L9 SWORD 1
	L10 BYTE 'a (boolean true) = ', 0
	L11 SWORD 0
	L12 BYTE 'b (boolean false) = ', 0
	L13 BYTE 'c (boolean yes) = ', 0
	L14 BYTE 'd (boolean no) = ', 0
	L15 BYTE 'e (boolean 1) = ', 0
	L16 BYTE 'f (boolean 0) = ', 0
	L17 SWORD 2
	L18 BYTE 'result = x + y * 2 = ', 0
	L19 SWORD 20
	L20 SWORD 3
	L21 BYTE 'divresult = 20 / 3 = ', 0
	L22 BYTE 'modresult = 20 % 3 = ', 0
	L23 BYTE 'A', 0
	L24 BYTE 'sym = ', 0
	L25 BYTE 'Hello', 0
	L26 BYTE 'World', 0
	L27 BYTE 'str1 = ', 0
	L28 BYTE 'str2 = ', 0
	L29 BYTE 'Cycle example (repeat 5 times):', 0
	L30 BYTE ' ', 0
	L31 SWORD 5
	L32 BYTE 'Iteration ', 0
	L33 BYTE 'Cycle finished. Final i = ', 0
	L34 BYTE '=== Testing Library Functions ===', 0
	L35 BYTE 'pow(2, 3) = 2 to power 3 = ', 0
	L36 BYTE 'pow(5, 2) = 5 to power 2 = ', 0
	L37 BYTE 'pow(10, 0) = 10 to power 0 = ', 0
	L38 BYTE 'Testing random function:', 0
	L39 BYTE 'random(1, 10) = ', 0
	L40 SWORD 50
	L41 SWORD 100
	L42 BYTE 'random(50, 100) = ', 0
	L43 BYTE 'Testing lenght function:', 0
	L44 BYTE 'Hello World', 0
	L45 BYTE 'lenght(teststr) where teststr = ', 0
	L46 BYTE ' = ', 0
	L47 BYTE 'lenght(str1) where str1 = ', 0
	L48 BYTE 'lenght(str2) where str2 = ', 0
	L49 BYTE 'Testing compare function:', 0
	L50 BYTE 'compare(str1, str2) = compare(Hello, World) = ', 0
	L51 BYTE 'compare(str1, str3) = compare(Hello, Hello) = ', 0
	L52 BYTE 'ABC', 0
	L53 BYTE 'XYZ', 0
	L54 BYTE 'compare(str4, str5) = compare(ABC, XYZ) = ', 0
	L55 BYTE '=== All tests completed! ===', 0
	L56 BYTE 'Program finished!', 0
.data
	mainx SWORD 0
	mainq SWORD 0
	mainy SWORD 0
	mainz SWORD 0
	maina SWORD 0
	mainb SWORD 0
	mainc SWORD 0
	maind SWORD 0
	maine SWORD 0
	mainf SWORD 0
	mainresult SWORD 0
	maindivresult SWORD 0
	mainmodresult SWORD 0
	mainsym DWORD ?
	mainstr1 DWORD ?
	mainstr2 DWORD ?
	maini SWORD 0
	mainpowresult SWORD 0
	mainpowresult2 SWORD 0
	mainpowresult3 SWORD 0
	mainrand1 SWORD 0
	mainrand2 SWORD 0
	mainteststr DWORD ?
	mainstrlen SWORD 0
	mainstrlen1 SWORD 0
	mainstrlen2 SWORD 0
	maincmp1 SWORD 0
	mainstr3 DWORD ?
	maincmp2 SWORD 0
	mainstr4 DWORD ?
	mainstr5 DWORD ?
	maincmp3 SWORD 0

.code

main PROC
	mov word ptr mainx, 26

push offset L2
call outstr

	movsx eax, word ptr mainx
	push eax
call outnumline
	mov word ptr mainq, -27

push offset L4
call outstr

	movsx eax, word ptr mainq
	push eax
call outnumline
	mov word ptr mainy, 10

push offset L6
call outstr

	movsx eax, word ptr mainy
	push eax
call outnumline
	mov word ptr mainz, -13

push offset L8
call outstr

	movsx eax, word ptr mainz
	push eax
call outnumline
	mov word ptr maina, 1

push offset L10
call outstr

	movsx eax, word ptr maina
	push eax
call outnumline
	mov word ptr mainb, 0

push offset L12
call outstr

	movsx eax, word ptr mainb
	push eax
call outnumline
	mov word ptr mainc, 1

push offset L13
call outstr

	movsx eax, word ptr mainc
	push eax
call outnumline
	mov word ptr maind, 0

push offset L14
call outstr

	movsx eax, word ptr maind
	push eax
call outnumline
	mov word ptr maine, 1

push offset L15
call outstr

	movsx eax, word ptr maine
	push eax
call outnumline
	mov word ptr mainf, 0

push offset L16
call outstr

	movsx eax, word ptr mainf
	push eax
call outnumline
	movsx eax, word ptr mainx
	push eax
	movsx eax, word ptr mainy
	push eax
	movsx eax, word ptr L17
	push eax
	pop ebx
	pop eax
	imul ebx
	push eax
	pop ebx
	pop eax
	add eax, ebx
	push eax
	pop eax
	mov word ptr mainresult, ax


push offset L18
call outstr

	movsx eax, word ptr mainresult
	push eax
call outnumline
	movsx eax, word ptr L19
	push eax
	movsx eax, word ptr L20
	push eax
	pop ebx
	pop eax
	cmp ebx,0
	je SOMETHINGWRONG
	cdq
	idiv ebx
	push eax
	pop eax
	mov word ptr maindivresult, ax


push offset L21
call outstr

	movsx eax, word ptr maindivresult
	push eax
call outnumline
	movsx eax, word ptr L19
	push eax
	movsx eax, word ptr L20
	push eax
	pop ebx
	pop eax
	cmp ebx,0
	je SOMETHINGWRONG
	cdq
	idiv ebx
	push edx
	pop eax
	mov word ptr mainmodresult, ax


push offset L22
call outstr

	movsx eax, word ptr mainmodresult
	push eax
call outnumline
	push offset L23
	pop mainsym


push offset L24
call outstr

push mainsym
call outstrline
	push offset L25
	pop mainstr1

	push offset L26
	pop mainstr2


push offset L27
call outstr

push mainstr1
call outstrline

push offset L28
call outstr

push mainstr2
call outstrline

push offset L29
call outstr

push offset L30
call outstrline
	mov word ptr maini, 0
	mov esi, 5
cycle1:

push offset L32
call outstr

	movsx eax, word ptr maini
	push eax
call outnumline
	movsx eax, word ptr maini
	push eax
	movsx eax, word ptr L9
	push eax
	pop ebx
	pop eax
	add eax, ebx
	push eax
	pop eax
	mov word ptr maini, ax

	dec esi
	cmp esi, 0
	jne cycle1
continue1:

push offset L33
call outstr

	movsx eax, word ptr maini
	push eax
call outnumline

push offset L34
call outstrline
	movsx eax, word ptr L17
	push eax
	movsx eax, word ptr L20
	push eax
	pop edx
	pop ecx
	push edx
	push ecx
		call power
	push eax
	pop eax
	mov word ptr mainpowresult, ax


push offset L35
call outstr

	movsx eax, word ptr mainpowresult
	push eax
call outnumline
	movsx eax, word ptr L31
	push eax
	movsx eax, word ptr L17
	push eax
	pop edx
	pop ecx
	push edx
	push ecx
		call power
	push eax
	pop eax
	mov word ptr mainpowresult2, ax


push offset L36
call outstr

	movsx eax, word ptr mainpowresult2
	push eax
call outnumline
	movsx eax, word ptr L5
	push eax
	movsx eax, word ptr L11
	push eax
	pop edx
	pop ecx
	push edx
	push ecx
		call power
	push eax
	pop eax
	mov word ptr mainpowresult3, ax


push offset L37
call outstr

	movsx eax, word ptr mainpowresult3
	push eax
call outnumline

push offset L30
call outstrline

push offset L38
call outstr
	movsx eax, word ptr L9
	push eax
	movsx eax, word ptr L5
	push eax
	pop edx
	pop ecx
	push edx
	push ecx
		call random
	push eax
	pop eax
	mov word ptr mainrand1, ax


push offset L39
call outstr

	movsx eax, word ptr mainrand1
	push eax
call outnumline
	movsx eax, word ptr L40
	push eax
	movsx eax, word ptr L41
	push eax
	pop edx
	pop ecx
	push edx
	push ecx
		call random
	push eax
	pop eax
	mov word ptr mainrand2, ax


push offset L42
call outstr

	movsx eax, word ptr mainrand2
	push eax
call outnumline

push offset L30
call outstrline

push offset L43
call outstr
	push offset L44
	pop mainteststr

	push mainteststr
		call lenght
	push eax
	pop eax
	mov word ptr mainstrlen, ax


push offset L45
call outstr

push mainteststr
call outstr

push offset L46
call outstr

	movsx eax, word ptr mainstrlen
	push eax
call outnumline
	push mainstr1
		call lenght
	push eax
	pop eax
	mov word ptr mainstrlen1, ax


push offset L47
call outstr

push mainstr1
call outstr

push offset L46
call outstr

	movsx eax, word ptr mainstrlen1
	push eax
call outnumline
	push mainstr2
		call lenght
	push eax
	pop eax
	mov word ptr mainstrlen2, ax


push offset L48
call outstr

push mainstr2
call outstr

push offset L46
call outstr

	movsx eax, word ptr mainstrlen2
	push eax
call outnumline

push offset L30
call outstrline

push offset L49
call outstr
	push mainstr1
	push mainstr2
	pop edx
	pop ecx
	push edx
	push ecx
		call compare
	push eax
	pop eax
	mov word ptr maincmp1, ax


push offset L50
call outstr

	movsx eax, word ptr maincmp1
	push eax
call outnumline
	push offset L25
	pop mainstr3

	push mainstr1
	push mainstr3
	pop edx
	pop ecx
	push edx
	push ecx
		call compare
	push eax
	pop eax
	mov word ptr maincmp2, ax


push offset L51
call outstr

	movsx eax, word ptr maincmp2
	push eax
call outnumline
	push offset L52
	pop mainstr4

	push offset L53
	pop mainstr5

	push mainstr4
	push mainstr5
	pop edx
	pop ecx
	push edx
	push ecx
		call compare
	push eax
	pop eax
	mov word ptr maincmp3, ax


push offset L54
call outstr

	movsx eax, word ptr maincmp3
	push eax
call outnumline

push offset L30
call outstrline

push offset L55
call outstrline

push offset L56
call outstr
call system_pause
push 0
call ExitProcess
SOMETHINGWRONG:
push offset null_division
call outstrline
call system_pause
push -1
call ExitProcess
EXIT_OVERFLOW:
push offset overflow
call outstrline
call system_pause
push -2
call ExitProcess
main ENDP
end main

